{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/contracts/applications/CCIPReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IAny2EVMMessageReceiver} from \"../interfaces/IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"../libraries/Client.sol\";\n\nimport {IERC165} from\n  \"@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n  address internal immutable i_ccipRouter;\n\n  constructor(\n    address router\n  ) {\n    if (router == address(0)) revert InvalidRouter(address(0));\n    i_ccipRouter = router;\n  }\n\n  /// @notice IERC165 supports an interfaceId.\n  /// @param interfaceId The interfaceId to check.\n  /// @return true if the interfaceId is supported.\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver.\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\n  /// This allows CCIP to check if ccipReceive is available before calling it.\n  /// - If this returns false or reverts, only tokens are transferred to the receiver.\n  /// - If this returns true, tokens are transferred and ccipReceive is called atomically.\n  /// Additionally, if the receiver address does not have code associated with it at the time of\n  /// execution (EXTCODESIZE returns 0), only tokens will be transferred.\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override returns (bool) {\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc IAny2EVMMessageReceiver\n  function ccipReceive(\n    Client.Any2EVMMessage calldata message\n  ) external virtual override onlyRouter {\n    _ccipReceive(message);\n  }\n\n  /// @notice Override this function in your implementation.\n  /// @param message Any2EVMMessage.\n  function _ccipReceive(\n    Client.Any2EVMMessage memory message\n  ) internal virtual;\n\n  /// @notice Return the current router\n  /// @return CCIP router address\n  function getRouter() public view virtual returns (address) {\n    return address(i_ccipRouter);\n  }\n\n  error InvalidRouter(address router);\n\n  /// @dev only calls from the set router are accepted.\n  modifier onlyRouter() {\n    if (msg.sender != getRouter()) revert InvalidRouter(msg.sender);\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/contracts/interfaces/IAny2EVMMessageReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from  the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message. If this reverts, any token transfers also revert.\n  /// The message will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message.\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter.\n  function ccipReceive(\n    Client.Any2EVMMessage calldata message\n  ) external;\n}\n"
    },
    "@chainlink/contracts-ccip/contracts/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains.\n    bytes data; // Data payload.\n    EVMTokenAmount[] tokenAmounts; // Token transfers.\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV2).\n  }\n\n  // Tag to indicate only a gas limit. Only usable for EVM as destination chain.\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(\n    EVMExtraArgsV1 memory extraArgs\n  ) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n\n  // Tag to indicate a gas limit (or dest chain equivalent processing units) and Out Of Order Execution. This tag is\n  // available for multiple chain families. If there is no chain family specific tag, this is the default available\n  // for a chain.\n  // Note: not available for Solana VM based chains.\n  bytes4 public constant GENERIC_EXTRA_ARGS_V2_TAG = 0x181dcf10;\n\n  /// @param gasLimit: gas limit for the callback on the destination chain.\n  /// @param allowOutOfOrderExecution: if true, it indicates that the message can be executed in any order relative to\n  /// other messages from the same sender. This value's default varies by chain. On some chains, a particular value is\n  /// enforced, meaning if the expected value is not set, the message request will revert.\n  /// @dev Fully compatible with the previously existing EVMExtraArgsV2.\n  struct GenericExtraArgsV2 {\n    uint256 gasLimit;\n    bool allowOutOfOrderExecution;\n  }\n\n  // Extra args tag for chains that use the Solana VM.\n  bytes4 public constant SVM_EXTRA_ARGS_V1_TAG = 0x1f3b3aba;\n\n  struct SVMExtraArgsV1 {\n    uint32 computeUnits;\n    uint64 accountIsWritableBitmap;\n    bool allowOutOfOrderExecution;\n    bytes32 tokenReceiver;\n    // Additional accounts needed for execution of CCIP receiver. Must be empty if message.receiver is zero.\n    // Token transfer related accounts are specified in the token pool lookup table on SVM.\n    bytes32[] accounts;\n  }\n\n  /// @dev The maximum number of accounts that can be passed in SVMExtraArgs.\n  uint256 public constant SVM_EXTRA_ARGS_MAX_ACCOUNTS = 64;\n\n  /// @dev The expected static payload size of a token transfer when Borsh encoded and submitted to SVM.\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\n  uint256 public constant SVM_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool\n    + 32 // token_address\n    + 4 // gas_amount\n    + 4 // extra_data overhead\n    + 32 // amount\n    + 32 // size of the token lookup table account\n    + 32 // token-related accounts in the lookup table, over-estimated to 32, typically between 11 - 13\n    + 32 // token account belonging to the token receiver, e.g ATA, not included in the token lookup table\n    + 32 // per-chain token pool config, not included in the token lookup table\n    + 32 // per-chain token billing config, not always included in the token lookup table\n    + 32; // OffRamp pool signer PDA, not included in the token lookup table\n\n  /// @dev Number of overhead accounts needed for message execution on SVM.\n  /// @dev These are message.receiver, and the OffRamp Signer PDA specific to the receiver.\n  uint256 public constant SVM_MESSAGING_ACCOUNTS_OVERHEAD = 2;\n\n  /// @dev The size of each SVM account address in bytes.\n  uint256 public constant SVM_ACCOUNT_BYTE_SIZE = 32;\n\n  function _argsToBytes(\n    GenericExtraArgsV2 memory extraArgs\n  ) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(GENERIC_EXTRA_ARGS_V2_TAG, extraArgs);\n  }\n\n  function _svmArgsToBytes(\n    SVMExtraArgsV1 memory extraArgs\n  ) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(SVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/automation/AutomationBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract AutomationBase {\n  error OnlySimulatedBackend();\n\n  /**\n   * @notice method that allows it to be simulated via eth_call by checking that\n   * the sender is the zero address.\n   */\n  function _preventExecution() internal view {\n    // solhint-disable-next-line avoid-tx-origin\n    if (tx.origin != address(0) && tx.origin != address(0x1111111111111111111111111111111111111111)) {\n      revert OnlySimulatedBackend();\n    }\n  }\n\n  /**\n   * @notice modifier that allows it to be simulated via eth_call by checking\n   * that the sender is the zero address.\n   */\n  modifier cannotExecute() {\n    _preventExecution();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AutomationBase} from \"./AutomationBase.sol\";\nimport {AutomationCompatibleInterface} from \"./interfaces/AutomationCompatibleInterface.sol\";\n\nabstract contract AutomationCompatible is AutomationBase, AutomationCompatibleInterface {}\n"
    },
    "@chainlink/contracts/src/v0.8/automation/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IFunctionsRouter} from \"./interfaces/IFunctionsRouter.sol\";\nimport {IFunctionsClient} from \"./interfaces/IFunctionsClient.sol\";\n\nimport {FunctionsRequest} from \"./libraries/FunctionsRequest.sol\";\n\n/// @title The Chainlink Functions client contract\n/// @notice Contract developers can inherit this contract in order to make Chainlink Functions requests\nabstract contract FunctionsClient is IFunctionsClient {\n  using FunctionsRequest for FunctionsRequest.Request;\n\n  IFunctionsRouter internal immutable i_router;\n\n  event RequestSent(bytes32 indexed id);\n  event RequestFulfilled(bytes32 indexed id);\n\n  error OnlyRouterCanFulfill();\n\n  constructor(address router) {\n    i_router = IFunctionsRouter(router);\n  }\n\n  /// @notice Sends a Chainlink Functions request\n  /// @param data The CBOR encoded bytes data for a Functions request\n  /// @param subscriptionId The subscription ID that will be charged to service the request\n  /// @param callbackGasLimit the amount of gas that will be available for the fulfillment callback\n  /// @return requestId The generated request ID for this request\n  function _sendRequest(\n    bytes memory data,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) internal returns (bytes32) {\n    bytes32 requestId = i_router.sendRequest(\n      subscriptionId,\n      data,\n      FunctionsRequest.REQUEST_DATA_VERSION,\n      callbackGasLimit,\n      donId\n    );\n    emit RequestSent(requestId);\n    return requestId;\n  }\n\n  /// @notice User defined function to handle a response from the DON\n  /// @param requestId The request ID, returned by sendRequest()\n  /// @param response Aggregated response from the execution of the user's source code\n  /// @param err Aggregated error from the execution of the user code or from the execution pipeline\n  /// @dev Either response or error parameter will be set, but never both\n  function fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal virtual;\n\n  /// @inheritdoc IFunctionsClient\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external override {\n    if (msg.sender != address(i_router)) {\n      revert OnlyRouterCanFulfill();\n    }\n    fulfillRequest(requestId, response, err);\n    emit RequestFulfilled(requestId);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/interfaces/IFunctionsClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Chainlink Functions client interface.\ninterface IFunctionsClient {\n  /// @notice Chainlink Functions response handler called by the Functions Router\n  /// during fullilment from the designated transmitter node in an OCR round.\n  /// @param requestId The requestId returned by FunctionsClient.sendRequest().\n  /// @param response Aggregated response from the request's source code.\n  /// @param err Aggregated error either from the request's source code or from the execution pipeline.\n  /// @dev Either response or error parameter will be set, but never both.\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/interfaces/IFunctionsRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsResponse} from \"../libraries/FunctionsResponse.sol\";\n\n/// @title Chainlink Functions Router interface.\ninterface IFunctionsRouter {\n  /// @notice The identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  /// @return id - bytes32 id that can be passed to the \"getContractById\" of the Router\n  function getAllowListId() external view returns (bytes32);\n\n  /// @notice Set the identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  function setAllowListId(bytes32 allowListId) external;\n\n  /// @notice Get the flat fee (in Juels of LINK) that will be paid to the Router owner for operation of the network\n  /// @return adminFee\n  function getAdminFee() external view returns (uint72 adminFee);\n\n  /// @notice Sends a request using the provided subscriptionId\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequest(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Sends a request to the proposed contracts\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequestToProposed(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Fulfill the request by:\n  /// - calling back the data that the Oracle returned to the client contract\n  /// - pay the DON for processing the request\n  /// @dev Only callable by the Coordinator contract that is saved in the commitment\n  /// @param response response data from DON consensus\n  /// @param err error from DON consensus\n  /// @param juelsPerGas - current rate of juels/gas\n  /// @param costWithoutFulfillment - The cost of processing the request (in Juels of LINK ), without fulfillment\n  /// @param transmitter - The Node that transmitted the OCR report\n  /// @param commitment - The parameters of the request that must be held consistent between request and response time\n  /// @return fulfillResult -\n  /// @return callbackGasCostJuels -\n  function fulfill(\n    bytes memory response,\n    bytes memory err,\n    uint96 juelsPerGas,\n    uint96 costWithoutFulfillment,\n    address transmitter,\n    FunctionsResponse.Commitment memory commitment\n  ) external returns (FunctionsResponse.FulfillResult, uint96);\n\n  /// @notice Validate requested gas limit is below the subscription max.\n  /// @param subscriptionId subscription ID\n  /// @param callbackGasLimit desired callback gas limit\n  function isValidCallbackGasLimit(uint64 subscriptionId, uint32 callbackGasLimit) external view;\n\n  /// @notice Get the current contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current contract address\n  function getContractById(bytes32 id) external view returns (address);\n\n  /// @notice Get the proposed next contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current or proposed contract address\n  function getProposedContractById(bytes32 id) external view returns (address);\n\n  /// @notice Return the latest proprosal set\n  /// @return ids The identifiers of the contracts to update\n  /// @return to The addresses of the contracts that will be updated to\n  function getProposedContractSet() external view returns (bytes32[] memory, address[] memory);\n\n  /// @notice Proposes one or more updates to the contract routes\n  /// @dev Only callable by owner\n  function proposeContractsUpdate(bytes32[] memory proposalSetIds, address[] memory proposalSetAddresses) external;\n\n  /// @notice Updates the current contract routes to the proposed contracts\n  /// @dev Only callable by owner\n  function updateContracts() external;\n\n  /// @dev Puts the system into an emergency stopped state.\n  /// @dev Only callable by owner\n  function pause() external;\n\n  /// @dev Takes the system out of an emergency stopped state.\n  /// @dev Only callable by owner\n  function unpause() external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {CBOR} from \"../../../vendor/solidity-cborutils/v2.0.0/CBOR.sol\";\n\n/// @title Library for encoding the input data of a Functions request into CBOR\nlibrary FunctionsRequest {\n  using CBOR for CBOR.CBORBuffer;\n\n  uint16 public constant REQUEST_DATA_VERSION = 1;\n  uint256 internal constant DEFAULT_BUFFER_SIZE = 256;\n\n  enum Location {\n    Inline, // Provided within the Request\n    Remote, // Hosted through remote location that can be accessed through a provided URL\n    DONHosted // Hosted on the DON's storage\n  }\n\n  enum CodeLanguage {\n    JavaScript\n    // In future version we may add other languages\n  }\n\n  struct Request {\n    Location codeLocation; // ════════════╸ The location of the source code that will be executed on each node in the DON\n    Location secretsLocation; // ═════════╸ The location of secrets that will be passed into the source code. *Only Remote secrets are supported\n    CodeLanguage language; // ════════════╸ The coding language that the source code is written in\n    string source; // ════════════════════╸ Raw source code for Request.codeLocation of Location.Inline, URL for Request.codeLocation of Location.Remote, or slot decimal number for Request.codeLocation of Location.DONHosted\n    bytes encryptedSecretsReference; // ══╸ Encrypted URLs for Request.secretsLocation of Location.Remote (use addSecretsReference()), or CBOR encoded slotid+version for Request.secretsLocation of Location.DONHosted (use addDONHostedSecrets())\n    string[] args; // ════════════════════╸ String arguments that will be passed into the source code\n    bytes[] bytesArgs; // ════════════════╸ Bytes arguments that will be passed into the source code\n  }\n\n  error EmptySource();\n  error EmptySecrets();\n  error EmptyArgs();\n  error NoInlineSecrets();\n\n  /// @notice Encodes a Request to CBOR encoded bytes\n  /// @param self The request to encode\n  /// @return CBOR encoded bytes\n  function encodeCBOR(Request memory self) internal pure returns (bytes memory) {\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\n\n    buffer.writeString(\"codeLocation\");\n    buffer.writeUInt256(uint256(self.codeLocation));\n\n    buffer.writeString(\"language\");\n    buffer.writeUInt256(uint256(self.language));\n\n    buffer.writeString(\"source\");\n    buffer.writeString(self.source);\n\n    if (self.args.length > 0) {\n      buffer.writeString(\"args\");\n      buffer.startArray();\n      for (uint256 i = 0; i < self.args.length; ++i) {\n        buffer.writeString(self.args[i]);\n      }\n      buffer.endSequence();\n    }\n\n    if (self.encryptedSecretsReference.length > 0) {\n      if (self.secretsLocation == Location.Inline) {\n        revert NoInlineSecrets();\n      }\n      buffer.writeString(\"secretsLocation\");\n      buffer.writeUInt256(uint256(self.secretsLocation));\n      buffer.writeString(\"secrets\");\n      buffer.writeBytes(self.encryptedSecretsReference);\n    }\n\n    if (self.bytesArgs.length > 0) {\n      buffer.writeString(\"bytesArgs\");\n      buffer.startArray();\n      for (uint256 i = 0; i < self.bytesArgs.length; ++i) {\n        buffer.writeBytes(self.bytesArgs[i]);\n      }\n      buffer.endSequence();\n    }\n\n    return buffer.buf.buf;\n  }\n\n  /// @notice Initializes a Chainlink Functions Request\n  /// @dev Sets the codeLocation and code on the request\n  /// @param self The uninitialized request\n  /// @param codeLocation The user provided source code location\n  /// @param language The programming language of the user code\n  /// @param source The user provided source code or a url\n  function initializeRequest(\n    Request memory self,\n    Location codeLocation,\n    CodeLanguage language,\n    string memory source\n  ) internal pure {\n    if (bytes(source).length == 0) revert EmptySource();\n\n    self.codeLocation = codeLocation;\n    self.language = language;\n    self.source = source;\n  }\n\n  /// @notice Initializes a Chainlink Functions Request\n  /// @dev Simplified version of initializeRequest for PoC\n  /// @param self The uninitialized request\n  /// @param javaScriptSource The user provided JS code (must not be empty)\n  function initializeRequestForInlineJavaScript(Request memory self, string memory javaScriptSource) internal pure {\n    initializeRequest(self, Location.Inline, CodeLanguage.JavaScript, javaScriptSource);\n  }\n\n  /// @notice Adds Remote user encrypted secrets to a Request\n  /// @param self The initialized request\n  /// @param encryptedSecretsReference Encrypted comma-separated string of URLs pointing to off-chain secrets\n  function addSecretsReference(Request memory self, bytes memory encryptedSecretsReference) internal pure {\n    if (encryptedSecretsReference.length == 0) revert EmptySecrets();\n\n    self.secretsLocation = Location.Remote;\n    self.encryptedSecretsReference = encryptedSecretsReference;\n  }\n\n  /// @notice Adds DON-hosted secrets reference to a Request\n  /// @param self The initialized request\n  /// @param slotID Slot ID of the user's secrets hosted on DON\n  /// @param version User data version (for the slotID)\n  function addDONHostedSecrets(Request memory self, uint8 slotID, uint64 version) internal pure {\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\n\n    buffer.writeString(\"slotID\");\n    buffer.writeUInt64(slotID);\n    buffer.writeString(\"version\");\n    buffer.writeUInt64(version);\n\n    self.secretsLocation = Location.DONHosted;\n    self.encryptedSecretsReference = buffer.buf.buf;\n  }\n\n  /// @notice Sets args for the user run function\n  /// @param self The initialized request\n  /// @param args The array of string args (must not be empty)\n  function setArgs(Request memory self, string[] memory args) internal pure {\n    if (args.length == 0) revert EmptyArgs();\n\n    self.args = args;\n  }\n\n  /// @notice Sets bytes args for the user run function\n  /// @param self The initialized request\n  /// @param args The array of bytes args (must not be empty)\n  function setBytesArgs(Request memory self, bytes[] memory args) internal pure {\n    if (args.length == 0) revert EmptyArgs();\n\n    self.bytesArgs = args;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsResponse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Library of types that are used for fulfillment of a Functions request\nlibrary FunctionsResponse {\n  // Used to send request information from the Router to the Coordinator\n  struct RequestMeta {\n    bytes data; // ══════════════════╸ CBOR encoded Chainlink Functions request data, use FunctionsRequest library to encode a request\n    bytes32 flags; // ═══════════════╸ Per-subscription flags\n    address requestingContract; // ══╗ The client contract that is sending the request\n    uint96 availableBalance; // ═════╝ Common LINK balance of the subscription that is controlled by the Router to be used for all consumer requests.\n    uint72 adminFee; // ═════════════╗ Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\n    uint64 subscriptionId; //        ║ Identifier of the billing subscription that will be charged for the request\n    uint64 initiatedRequests; //     ║ The number of requests that have been started\n    uint32 callbackGasLimit; //      ║ The amount of gas that the callback to the consuming contract will be given\n    uint16 dataVersion; // ══════════╝ The version of the structure of the CBOR encoded request data\n    uint64 completedRequests; // ════╗ The number of requests that have successfully completed or timed out\n    address subscriptionOwner; // ═══╝ The owner of the billing subscription\n  }\n\n  enum FulfillResult {\n    FULFILLED, // 0\n    USER_CALLBACK_ERROR, // 1\n    INVALID_REQUEST_ID, // 2\n    COST_EXCEEDS_COMMITMENT, // 3\n    INSUFFICIENT_GAS_PROVIDED, // 4\n    SUBSCRIPTION_BALANCE_INVARIANT_VIOLATION, // 5\n    INVALID_COMMITMENT // 6\n  }\n\n  struct Commitment {\n    bytes32 requestId; // ═════════════════╸ A unique identifier for a Chainlink Functions request\n    address coordinator; // ═══════════════╗ The Coordinator contract that manages the DON that is servicing a request\n    uint96 estimatedTotalCostJuels; // ════╝ The maximum cost in Juels (1e18) of LINK that will be charged to fulfill a request\n    address client; // ════════════════════╗ The client contract that sent the request\n    uint64 subscriptionId; //              ║ Identifier of the billing subscription that will be charged for the request\n    uint32 callbackGasLimit; // ═══════════╝ The amount of gas that the callback to the consuming contract will be given\n    uint72 adminFee; // ═══════════════════╗ Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\n    uint72 donFee; //                      ║ Fee (in Juels of LINK) that will be split between Node Operators for servicing a request\n    uint40 gasOverheadBeforeCallback; //   ║ Represents the average gas execution cost before the fulfillment callback.\n    uint40 gasOverheadAfterCallback; //    ║ Represents the average gas execution cost after the fulfillment callback.\n    uint32 timeoutTimestamp; // ═══════════╝ The timestamp at which a request will be eligible to be timed out\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwnerWithProposal} from \"./ConfirmedOwnerWithProposal.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    // solhint-disable-next-line gas-custom-errors\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  function _transferOwnership(address to) private {\n    // solhint-disable-next-line gas-custom-errors\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/@ensdomains/buffer/v0.1.0/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}"
    },
    "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/solidity-cborutils/v2.0.0/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../@ensdomains/buffer/v0.1.0/Buffer.sol\";\n\n/**\n* @dev A library for populating CBOR encoded payload in Solidity.\n*\n* https://datatracker.ietf.org/doc/html/rfc7049\n*\n* The library offers various write* and start* methods to encode values of different types.\n* The resulted buffer can be obtained with data() method.\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\n* in an invalid CBOR if start/write/end flow is violated.\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\n* except for nested start/end pairs.\n*/\n\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    struct CBORBuffer {\n        Buffer.buffer buf;\n        uint256 depth;\n    }\n\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    uint8 private constant CBOR_FALSE = 20;\n    uint8 private constant CBOR_TRUE = 21;\n    uint8 private constant CBOR_NULL = 22;\n    uint8 private constant CBOR_UNDEFINED = 23;\n\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\n        Buffer.init(cbor.buf, capacity);\n        cbor.depth = 0;\n        return cbor;\n    }\n\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\n        require(buf.depth == 0, \"Invalid CBOR\");\n        return buf.buf.buf;\n    }\n\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        writeBytes(buf, abi.encode(value));\n    }\n\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\n        if (value < 0) {\n            buf.buf.appendUint8(\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\n            );\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\n        } else {\n            writeUInt256(buf, uint256(value));\n        }\n    }\n\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\n    }\n\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\n        if(value >= 0) {\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        } else{\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\n        }\n    }\n\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.buf.append(value);\n    }\n\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.buf.append(bytes(value));\n    }\n\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\n    }\n\n    function writeNull(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_NULL);\n    }\n\n    function writeUndefined(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_UNDEFINED);\n    }\n\n    function startArray(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n        buf.depth += 1;\n    }\n\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\n    }\n\n    function startMap(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n        buf.depth += 1;\n    }\n\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\n    }\n\n    function endSequence(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n        buf.depth -= 1;\n    }\n\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\n        writeString(buf, key);\n        writeString(buf, value);\n    }\n\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\n        writeString(buf, key);\n        writeBytes(buf, value);\n    }\n\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\n        writeString(buf, key);\n        writeUInt256(buf, value);\n    }\n\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\n        writeString(buf, key);\n        writeInt256(buf, value);\n    }\n\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\n        writeString(buf, key);\n        writeUInt64(buf, value);\n    }\n\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\n        writeString(buf, key);\n        writeInt64(buf, value);\n    }\n\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\n        writeString(buf, key);\n        writeBool(buf, value);\n    }\n\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeNull(buf);\n    }\n\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeUndefined(buf);\n    }\n\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startMap(buf);\n    }\n\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startArray(buf);\n    }\n\n    function writeFixedNumeric(\n        CBORBuffer memory buf,\n        uint8 major,\n        uint64 value\n    ) private pure {\n        if (value <= 23) {\n            buf.buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 24));\n            buf.buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 25));\n            buf.buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 26));\n            buf.buf.appendInt(value, 4);\n        } else {\n            buf.buf.appendUint8(uint8((major << 5) | 27));\n            buf.buf.appendInt(value, 8);\n        }\n    }\n\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\n        private\n        pure\n    {\n        buf.buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\n        private\n        pure\n    {\n        writeFixedNumeric(buf, major, length);\n    }\n\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\n    }\n}"
    },
    "@chainlink/contracts/src/v0.8/vrf/interfaces/VRFCoordinatorV2Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig() external view returns (uint16, uint32, bytes32[] memory);\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(\n    uint64 subId\n  ) external view returns (uint96 balance, uint64 reqCount, address owner, address[] memory consumers);\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n\n  /*\n   * @notice Check to see if there exists a request commitment consumers\n   * for all consumers and keyhashes for a given sub.\n   * @param subId - ID of the subscription\n   * @return true if there exists at least one unfulfilled request for the subscription, false\n   * otherwise.\n   */\n  function pendingRequestExists(uint64 subId) external view returns (bool);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  // solhint-disable-next-line chainlink-solidity/prefix-immutable-variables-with-i\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/AIMarketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsClient} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol\";\nimport {FunctionsRequest} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol\";\n\ncontract AIMarketplace is FunctionsClient {\n    using FunctionsRequest for FunctionsRequest.Request;\n\n    struct AIRecommendation {\n        address user;\n        string query;\n        uint256 timestamp;\n        bytes32 requestId;\n        string[] recommendedProducts;\n        uint256[] sustainabilityScores;\n    }\n\n    mapping(bytes32 => AIRecommendation) public recommendations;\n    mapping(address => bytes32[]) public userRecommendations;\n\n    uint64 public subscriptionId;\n    uint32 public gasLimit = 300000;\n    bytes32 public donId; // Chainlink Functions DON ID\n\n    string public bedrockSource = \n        \"const query = args[0];\"\n        \"const preferences = JSON.parse(args[1]);\"\n        \"const apiKey = secrets.AWS_ACCESS_KEY;\"\n        \"const secretKey = secrets.AWS_SECRET_KEY;\"\n        \"\"\n        \"// Call Amazon Bedrock API\"\n        \"const bedrockResponse = await Functions.makeHttpRequest({\"\n        \"  url: 'https://bedrock-runtime.us-east-1.amazonaws.com/model/anthropic.claude-3-haiku-20240307-v1:0/invoke',\"\n        \"  method: 'POST',\"\n        \"  headers: {\"\n        \"    'Content-Type': 'application/json',\"\n        \"    'Authorization': `AWS4-HMAC-SHA256 Credential=${apiKey}/...`\"\n        \"  },\"\n        \"  data: {\"\n        \"    prompt: `Find sustainable products: ${query}`,\"\n        \"    max_tokens: 1000\"\n        \"  }\"\n        \"});\"\n        \"\"\n        \"return Functions.encodeString(JSON.stringify(bedrockResponse.data));\";\n\n    event AIRecommendationRequested(\n        address indexed user,\n        bytes32 indexed requestId,\n        string query\n    );\n\n    event AIRecommendationFulfilled(\n        address indexed user,\n        bytes32 indexed requestId,\n        string[] products\n    );\n\n    constructor(address router) FunctionsClient(router) {}\n\n    function requestAIRecommendation(\n        string memory query,\n        string memory preferencesJson\n    ) external returns (bytes32 requestId) {\n        FunctionsRequest.Request memory req;\n        req.initializeRequestForInlineJavaScript(bedrockSource);\n        \n        string[] memory args = new string[](2);\n        args[0] = query;\n        args[1] = preferencesJson;\n        req.setArgs(args);\n\n        // Add AWS credentials as encrypted secrets\n        req.addSecretsReference(\"AWS_ACCESS_KEY\");\n        req.addSecretsReference(\"AWS_SECRET_KEY\");\n        \n        requestId = _sendRequest(\n            req.encodeCBOR(),\n            subscriptionId,\n            gasLimit,\n            donId\n        );\n\n        recommendations[requestId] = AIRecommendation({\n            user: msg.sender,\n            query: query,\n            timestamp: block.timestamp,\n            requestId: requestId,\n            recommendedProducts: new string[](0),\n            sustainabilityScores: new uint256[](0)\n        });\n\n        userRecommendations[msg.sender].push(requestId);\n        \n        emit AIRecommendationRequested(msg.sender, requestId, query);\n    }\n\n    function fulfillRequest(\n        bytes32 requestId,\n        bytes memory response,\n        bytes memory err\n    ) internal override {\n        AIRecommendation storage rec = recommendations[requestId];\n        \n        if (err.length > 0) {\n            // Handle error\n            return;\n        }\n\n        // Parse response and update recommendation\n        // This is simplified - actual implementation would parse JSON\n        string memory responseStr = string(response);\n        \n        // Update recommendation with parsed data\n        rec.recommendedProducts = parseProducts(responseStr);\n        rec.sustainabilityScores = parseScores(responseStr);\n        \n        emit AIRecommendationFulfilled(\n            rec.user,\n            requestId,\n            rec.recommendedProducts\n        );\n    }\n\n    // Helper functions to parse response (implement based on response format)\n    function parseProducts(string memory response) internal pure returns (string[] memory) {\n        // Implementation needed\n        string[] memory products = new string[](1);\n        products[0] = \"Sustainable Product\";\n        return products;\n    }\n\n    function parseScores(string memory response) internal pure returns (uint256[] memory) {\n        // Implementation needed\n        uint256[] memory scores = new uint256[](1);\n        scores[0] = 85;\n        return scores;\n    }\n\n    // Admin functions\n    function setSubscriptionId(uint64 _subscriptionId) external {\n        subscriptionId = _subscriptionId;\n    }\n\n    function setDonId(bytes32 _donId) external {\n        donId = _donId;\n    }\n\n    function setGasLimit(uint32 _gasLimit) external {\n        gasLimit = _gasLimit;\n    }\n}\n"
    },
    "contracts/core/AIRecommendations.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsClient} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol\";\nimport {ConfirmedOwner} from \"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol\";\nimport {FunctionsRequest} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol\";\nimport {VRFConsumerBaseV2} from \"@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol\";\nimport {VRFCoordinatorV2Interface} from \"@chainlink/contracts/src/v0.8/vrf/interfaces/VRFCoordinatorV2Interface.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"hardhat/console.sol\";\n\ninterface IEscrowManager {\n    function getEscrow(uint256 _escrowId) external view returns (\n        uint256 id,\n        address buyer,\n        address seller,\n        uint256 productId,\n        uint256 amount,\n        address token,\n        uint8 status,\n        uint256 createdAt,\n        uint256 disputeId,\n        uint64 sourceChainSelector,\n        bool isActive\n    );\n    \n    function resolveDisputeWithDistribution(\n        uint256 _escrowId,\n        uint256 _buyerRefundPercent\n    ) external;\n    \n    function isValidEscrow(uint256 _escrowId) external view returns (bool);\n}\n\ninterface IProductRegistry {\n    struct Product {\n        uint256 id;\n        uint256 price;\n        uint256 createdAt;\n        uint256 totalSales;\n        uint256 totalReviews;\n        uint256 averageRating;\n        address seller;\n        bool isActive;\n        string name;\n        string description;\n        string category;\n        string imageHash;\n        string metadataHash;\n    }\n\n    function getProductForAI(uint256 _productId) \n        external \n        view \n        returns (\n            string memory name,\n            string memory category,\n            uint256 price,\n            uint256 rating,\n            address seller,\n            bool isActive\n        );\n    \n    function getProductsByCategory(string memory _category) \n        external \n        view \n        returns (uint256[] memory);\n    \n    function getBatchProducts(uint256[] calldata _productIds)\n        external\n        view\n        returns (Product[] memory);\n    \n    function getCategories() external view returns (string[] memory);\n    \n    function getSellerReputation(address _seller) \n        external \n        view \n        returns (uint256 reputation, bool isVerified, uint256 totalSales);\n}\n\n/**\n * @title AIRecommendations\n * @dev Chainlink Functions integration for AI-powered product recommendations\n * @author AI Marketplace Team\n */\ncontract AIRecommendations is FunctionsClient, VRFConsumerBaseV2, ConfirmedOwner, ReentrancyGuard {\n    using FunctionsRequest for FunctionsRequest.Request;\n\n    // Events\n    event RecommendationRequested(\n        bytes32 indexed requestId,\n        address indexed user,\n        string preferences,\n        uint256 maxResults\n    );\n    \n    event RecommendationReceived(\n        bytes32 indexed requestId,\n        address indexed user,\n        uint256[] productIds,\n        uint256[] scores\n    );\n    \n    event AIPreferencesUpdated(\n        address indexed user,\n        string preferences\n    );\n    \n    // Dispute Events\n    event DisputeCreated(\n        uint256 indexed disputeId,\n        uint256 indexed escrowId,\n        address indexed initiator,\n        string evidence\n    );\n    \n    event DisputeAnalyzed(\n        uint256 indexed disputeId,\n        bytes32 indexed requestId,\n        uint256 aiRecommendedRefundPercent,\n        string reasoning\n    );\n    \n    event ArbitratorSelected(\n        uint256 indexed disputeId,\n        address indexed arbitrator,\n        uint256 vrfRequestId\n    );\n    \n    event DisputeResolved(\n        uint256 indexed disputeId,\n        uint256 indexed escrowId,\n        uint256 buyerRefundPercent,\n        address resolvedBy\n    );\n\n    // Enums\n    enum DisputeStatus {\n        Open,\n        AIAnalyzed,\n        ArbitratorAssigned,\n        Resolved\n    }\n    \n    enum RequestType {\n        Recommendation,\n        DisputeAnalysis\n    }\n    \n    // Structs\n    struct DisputeCase {\n        uint256 id;\n        uint256 escrowId;\n        address buyer;\n        address seller;\n        uint256 amount;\n        address token;\n        string evidence;\n        uint256 aiRecommendedRefundPercent;\n        string aiReasoning;\n        address assignedArbitrator;\n        DisputeStatus status;\n        uint256 createdAt;\n        uint256 resolvedAt;\n        bool exists;\n    }\n    \n    struct UserPreferences {\n        string categories; // JSON string of preferred categories\n        string priceRange; // \"min,max\" in wei\n        string sustainability; // \"high,medium,low,none\"\n        string brand; // preferred brands\n        string customPrefs; // additional AI context\n        uint256 updatedAt;\n        bool exists;\n    }\n\n    struct RecommendationRequest {\n        address user;\n        bool fulfilled;\n        uint256 maxResults;\n        uint256 timestamp;\n        string preferences;\n        RequestType requestType;\n        uint256 disputeId; // Only used for dispute analysis requests\n    }\n\n    // State variables\n    IProductRegistry public productRegistry;\n    IEscrowManager public escrowManager;\n    \n    // Dispute management\n    uint256 public nextDisputeId = 1;\n    mapping(uint256 => DisputeCase) public disputes;\n    mapping(address => uint256[]) public userDisputes;\n    mapping(uint256 => uint256) public escrowToDispute; // escrowId => disputeId\n    \n    // Arbitrator management\n    address[] public arbitratorQueue;\n    mapping(address => bool) public isArbitrator;\n    mapping(address => uint256) public arbitratorCaseCount;\n    uint256 public maxCasesPerArbitrator = 5;\n    \n    // VRF Configuration\n    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;\n    uint64 private immutable i_vrfSubscriptionId;\n    bytes32 private immutable i_gasLane;\n    uint32 private immutable i_callbackGasLimit;\n    uint16 private constant REQUEST_CONFIRMATIONS = 3;\n    mapping(uint256 => uint256) public vrfRequestToDisputeId;\n    \n    // Enhanced Functions configuration\n    string public disputeAnalysisSourceCode;\n    \n    // Chainlink Functions configuration\n    bytes32 public s_lastRequestId;\n    bytes public s_lastResponse;\n    bytes public s_lastError;\n    \n    // Function configuration\n    string public sourceCode;\n    uint64 public subscriptionId;\n    uint32 public gasLimit;\n    bytes32 public donID;\n    \n    // User data\n    mapping(address => UserPreferences) public userPreferences;\n    mapping(bytes32 => RecommendationRequest) public requests;\n    mapping(address => bytes32[]) public userRequestHistory;\n    \n    // Latest recommendations for each user\n    mapping(address => uint256[]) public latestRecommendations;\n    mapping(address => uint256[]) public latestScores;\n    mapping(address => uint256) public lastRecommendationTime;\n\n    // Access control\n    mapping(address => bool) public authorizedCallers;\n\n    // Modifiers\n    modifier onlyAuthorized() {\n        require(authorizedCallers[msg.sender] || msg.sender == owner(), \"Not authorized\");\n        _;\n    }\n\n    constructor(\n        address router,\n        address _productRegistry,\n        address _escrowManager,\n        address _vrfCoordinator,\n        uint64 _vrfSubscriptionId,\n        bytes32 _gasLane,\n        uint32 _callbackGasLimit\n    ) FunctionsClient(router) VRFConsumerBaseV2(_vrfCoordinator) ConfirmedOwner(msg.sender) {\n        productRegistry = IProductRegistry(_productRegistry);\n        escrowManager = IEscrowManager(_escrowManager);\n        authorizedCallers[msg.sender] = true;\n        \n        i_vrfCoordinator = VRFCoordinatorV2Interface(_vrfCoordinator);\n        i_vrfSubscriptionId = _vrfSubscriptionId;\n        i_gasLane = _gasLane;\n        i_callbackGasLimit = _callbackGasLimit;\n        \n        console.log(\"AIRecommendations deployed\");\n        console.log(\"ProductRegistry:\", _productRegistry);\n        console.log(\"EscrowManager:\", _escrowManager);\n        console.log(\"Functions Router:\", router);\n    }\n\n    /**\n     * @dev Initialize Chainlink Functions configuration\n     */\n    function initializeFunctions(\n        string memory _sourceCode,\n        uint64 _subscriptionId,\n        uint32 _gasLimit,\n        bytes32 _donID\n    ) external onlyOwner {\n        sourceCode = _sourceCode;\n        subscriptionId = _subscriptionId;\n        gasLimit = _gasLimit;\n        donID = _donID;\n        \n        console.log(\"Functions initialized\");\n        console.log(\"Subscription ID:\", _subscriptionId);\n    }\n\n    /**\n     * @dev Set or update user AI preferences\n     */\n    function setUserPreferences(\n        string memory _categories,\n        string memory _priceRange,\n        string memory _sustainability,\n        string memory _brand,\n        string memory _customPrefs\n    ) external {\n        userPreferences[msg.sender] = UserPreferences({\n            categories: _categories,\n            priceRange: _priceRange,\n            sustainability: _sustainability,\n            brand: _brand,\n            customPrefs: _customPrefs,\n            updatedAt: block.timestamp,\n            exists: true\n        });\n        \n        emit AIPreferencesUpdated(msg.sender, _categories);\n        console.log(\"Preferences updated for:\", msg.sender);\n    }\n\n    /**\n     * @dev Request AI-powered product recommendations\n     */\n    function requestRecommendations(\n        uint256 _maxResults\n    ) external returns (bytes32 requestId) {\n        require(userPreferences[msg.sender].exists, \"No user preferences set\");\n        require(_maxResults > 0 && _maxResults <= 20, \"Invalid max results\");\n        \n        // Prepare the request data\n        string memory prefsJson = _buildPreferencesJson(msg.sender);\n        string memory productDataJson = _getProductDataForAI();\n        \n        // Build Chainlink Functions request using the library\n        FunctionsRequest.Request memory req;\n        req.initializeRequestForInlineJavaScript(sourceCode);\n        \n        // Set request arguments\n        string[] memory args = new string[](3);\n        args[0] = prefsJson; // User preferences\n        args[1] = productDataJson; // Product data\n        args[2] = _uint2str(_maxResults); // Max results\n        req.setArgs(args);\n        \n        // Send the request\n        s_lastRequestId = _sendRequest(\n            req.encodeCBOR(),\n            subscriptionId,\n            gasLimit,\n            donID\n        );\n        \n        // Store request details\n        requests[s_lastRequestId] = RecommendationRequest({\n            user: msg.sender,\n            preferences: prefsJson,\n            maxResults: _maxResults,\n            timestamp: block.timestamp,\n            fulfilled: false,\n            requestType: RequestType.Recommendation,\n            disputeId: 0\n        });\n        \n        userRequestHistory[msg.sender].push(s_lastRequestId);\n        \n        emit RecommendationRequested(s_lastRequestId, msg.sender, prefsJson, _maxResults);\n        \n        console.log(\"Recommendation requested for:\", msg.sender);\n        console.log(\"Request ID:\", bytes32ToString(s_lastRequestId));\n        \n        return s_lastRequestId;\n    }\n\n    /**\n     * @dev Callback function for Chainlink Functions\n     */\n    function fulfillRequest(\n        bytes32 requestId,\n        bytes memory response,\n        bytes memory err\n    ) internal override {\n        if (err.length > 0) {\n            s_lastError = err;\n            console.log(\"Functions error:\", string(err));\n            return;\n        }\n        \n        s_lastResponse = response;\n        \n        RecommendationRequest storage request = requests[requestId];\n        require(request.user != address(0), \"Invalid request\");\n        \n        if (request.requestType == RequestType.Recommendation) {\n            // Handle recommendation response\n            (uint256[] memory productIds, uint256[] memory scores) = _parseAIResponse(response);\n            \n            // Store latest recommendations\n            latestRecommendations[request.user] = productIds;\n            latestScores[request.user] = scores;\n            lastRecommendationTime[request.user] = block.timestamp;\n            \n            emit RecommendationReceived(requestId, request.user, productIds, scores);\n            console.log(\"Recommendations fulfilled for:\", request.user);\n            console.log(\"Products recommended:\", productIds.length);\n            \n        } else if (request.requestType == RequestType.DisputeAnalysis) {\n            // Handle dispute analysis response\n            (uint256 refundPercent, string memory reasoning) = _parseDisputeResponse(response);\n            \n            DisputeCase storage dispute = disputes[request.disputeId];\n            dispute.aiRecommendedRefundPercent = refundPercent;\n            dispute.aiReasoning = reasoning;\n            dispute.status = DisputeStatus.AIAnalyzed;\n            \n            emit DisputeAnalyzed(\n                request.disputeId,\n                requestId,\n                refundPercent,\n                reasoning\n            );\n            \n            // Request arbitrator selection after AI analysis\n            _requestArbitratorSelection(request.disputeId);\n            \n            console.log(\"Dispute analysis fulfilled for:\", request.disputeId);\n            console.log(\"AI recommended refund %:\", refundPercent);\n        }\n        \n        // Mark request as fulfilled\n        request.fulfilled = true;\n    }\n    \n    /**\n     * @dev VRF callback function (required by VRFConsumerBaseV2)\n     */\n    function fulfillRandomWords(\n        uint256 _requestId,\n        uint256[] memory _randomWords\n    ) internal override {\n        uint256 disputeId = vrfRequestToDisputeId[_requestId];\n        require(disputeId != 0, \"Invalid VRF request\");\n        \n        DisputeCase storage dispute = disputes[disputeId];\n        require(dispute.status == DisputeStatus.AIAnalyzed, \"Invalid dispute status\");\n        \n        // Select random arbitrator from available queue\n        if (arbitratorQueue.length > 0) {\n            uint256 randomIndex = _randomWords[0] % arbitratorQueue.length;\n            address selectedArbitrator = arbitratorQueue[randomIndex];\n            \n            // Assign arbitrator if they haven't exceeded max cases\n            if (arbitratorCaseCount[selectedArbitrator] < maxCasesPerArbitrator) {\n                dispute.assignedArbitrator = selectedArbitrator;\n                dispute.status = DisputeStatus.ArbitratorAssigned;\n                arbitratorCaseCount[selectedArbitrator]++;\n                \n                emit ArbitratorSelected(disputeId, selectedArbitrator, _requestId);\n                console.log(\"Arbitrator selected for dispute:\", disputeId, \"arbitrator:\", selectedArbitrator);\n            } else {\n                // Find next available arbitrator\n                for (uint256 i = 0; i < arbitratorQueue.length; i++) {\n                    address arbitrator = arbitratorQueue[i];\n                    if (arbitratorCaseCount[arbitrator] < maxCasesPerArbitrator) {\n                        dispute.assignedArbitrator = arbitrator;\n                        dispute.status = DisputeStatus.ArbitratorAssigned;\n                        arbitratorCaseCount[arbitrator]++;\n                        \n                        emit ArbitratorSelected(disputeId, arbitrator, _requestId);\n                        console.log(\"Arbitrator assigned for dispute:\", disputeId, \"arbitrator:\", arbitrator);\n                        break;\n                    }\n                }\n            }\n        }\n        \n        delete vrfRequestToDisputeId[_requestId];\n    }\n\n    // Dispute Resolution Functions\n    \n    /**\n     * @dev Analyze a dispute using AI (called by EscrowManager)\n     */\n    function analyzeDispute(\n        uint256 _escrowId,\n        string memory _evidence\n    ) external onlyAuthorized nonReentrant returns (uint256) {\n        require(escrowManager.isValidEscrow(_escrowId), \"Invalid escrow\");\n        require(escrowToDispute[_escrowId] == 0, \"Dispute already exists\");\n        require(bytes(_evidence).length > 0, \"Evidence required\");\n        \n        // Get escrow details\n        (\n            ,\n            address buyer,\n            address seller,\n            ,\n            uint256 amount,\n            address token,\n            ,\n            ,\n            ,\n            ,\n            \n        ) = escrowManager.getEscrow(_escrowId);\n        \n        // Create dispute case\n        uint256 disputeId = nextDisputeId++;\n        disputes[disputeId] = DisputeCase({\n            id: disputeId,\n            escrowId: _escrowId,\n            buyer: buyer,\n            seller: seller,\n            amount: amount,\n            token: token,\n            evidence: _evidence,\n            aiRecommendedRefundPercent: 0,\n            aiReasoning: \"\",\n            assignedArbitrator: address(0),\n            status: DisputeStatus.Open,\n            createdAt: block.timestamp,\n            resolvedAt: 0,\n            exists: true\n        });\n        \n        // Track dispute\n        escrowToDispute[_escrowId] = disputeId;\n        userDisputes[buyer].push(disputeId);\n        userDisputes[seller].push(disputeId);\n        \n        // Request AI analysis if available\n        if (bytes(disputeAnalysisSourceCode).length > 0) {\n            _requestAIDisputeAnalysis(disputeId);\n        } else {\n            // Skip AI analysis and go straight to arbitrator selection\n            _requestArbitratorSelection(disputeId);\n        }\n        \n        emit DisputeCreated(disputeId, _escrowId, buyer, _evidence);\n        console.log(\"Dispute created:\", disputeId, \"for escrow:\", _escrowId);\n        \n        return disputeId;\n    }\n    \n    /**\n     * @dev Request arbitrator selection using VRF\n     */\n    function requestArbitratorSelection(uint256 _disputeId) external onlyAuthorized {\n        _requestArbitratorSelection(_disputeId);\n    }\n    \n    function _requestArbitratorSelection(uint256 _disputeId) internal {\n        require(disputes[_disputeId].exists, \"Dispute does not exist\");\n        require(arbitratorQueue.length > 0, \"No arbitrators available\");\n        \n        DisputeCase storage dispute = disputes[_disputeId];\n        require(\n            dispute.status == DisputeStatus.Open || dispute.status == DisputeStatus.AIAnalyzed,\n            \"Invalid dispute status\"\n        );\n        \n        // Request random words from VRF\n        uint256 requestId = i_vrfCoordinator.requestRandomWords(\n            i_gasLane,\n            i_vrfSubscriptionId,\n            REQUEST_CONFIRMATIONS,\n            i_callbackGasLimit,\n            1\n        );\n        \n        vrfRequestToDisputeId[requestId] = _disputeId;\n        \n        // Update status if coming from Open (no AI analysis)\n        if (dispute.status == DisputeStatus.Open) {\n            dispute.status = DisputeStatus.AIAnalyzed;\n        }\n    }\n    \n    /**\n     * @dev Resolve dispute with fund distribution (called by arbitrator)\n     */\n    function resolveDispute(\n        uint256 _disputeId,\n        uint256 _buyerRefundPercent\n    ) external nonReentrant {\n        require(_buyerRefundPercent <= 100, \"Invalid refund percentage\");\n        \n        DisputeCase storage dispute = disputes[_disputeId];\n        require(dispute.exists, \"Dispute does not exist\");\n        require(dispute.status == DisputeStatus.ArbitratorAssigned, \"Invalid dispute status\");\n        require(msg.sender == dispute.assignedArbitrator, \"Only assigned arbitrator\");\n        \n        // Update dispute status\n        dispute.status = DisputeStatus.Resolved;\n        dispute.resolvedAt = block.timestamp;\n        \n        // Decrease arbitrator case count\n        arbitratorCaseCount[dispute.assignedArbitrator]--;\n        \n        // Call EscrowManager to distribute funds\n        escrowManager.resolveDisputeWithDistribution(\n            dispute.escrowId,\n            _buyerRefundPercent\n        );\n        \n        emit DisputeResolved(\n            _disputeId,\n            dispute.escrowId,\n            _buyerRefundPercent,\n            msg.sender\n        );\n        \n        console.log(\"Dispute resolved:\", _disputeId, \"refund %:\", _buyerRefundPercent);\n    }\n    \n    /**\n     * @dev Request AI analysis for dispute\n     */\n    function _requestAIDisputeAnalysis(uint256 _disputeId) internal {\n        DisputeCase storage dispute = disputes[_disputeId];\n        \n        // Build request\n        FunctionsRequest.Request memory req;\n        req.initializeRequestForInlineJavaScript(disputeAnalysisSourceCode);\n        \n        // Set arguments for dispute analysis\n        string[] memory args = new string[](6);\n        args[0] = _uint2str(dispute.escrowId);\n        args[1] = dispute.evidence;\n        args[2] = _addressToString(dispute.buyer);\n        args[3] = _addressToString(dispute.seller);\n        args[4] = _uint2str(dispute.amount);\n        args[5] = _addressToString(dispute.token);\n        req.setArgs(args);\n        \n        // Send request\n        bytes32 requestId = _sendRequest(\n            req.encodeCBOR(),\n            subscriptionId,\n            gasLimit,\n            donID\n        );\n        \n        // Store request details for dispute analysis\n        requests[requestId] = RecommendationRequest({\n            user: dispute.buyer,\n            preferences: dispute.evidence,\n            maxResults: 0,\n            timestamp: block.timestamp,\n            fulfilled: false,\n            requestType: RequestType.DisputeAnalysis,\n            disputeId: _disputeId\n        });\n        \n        s_lastRequestId = requestId;\n        console.log(\"AI dispute analysis requested for:\", _disputeId);\n    }\n\n    /**\n     * @dev Get user's latest recommendations\n     */\n    function getLatestRecommendations(address _user) \n        external \n        view \n        returns (uint256[] memory productIds, uint256[] memory scores, uint256 timestamp) \n    {\n        return (\n            latestRecommendations[_user],\n            latestScores[_user],\n            lastRecommendationTime[_user]\n        );\n    }\n\n    /**\n     * @dev Get detailed recommendations with product info\n     */\n    function getDetailedRecommendations(address _user) \n        external \n        view \n        returns (\n            IProductRegistry.Product[] memory products,\n            uint256[] memory scores\n        ) \n    {\n        uint256[] memory productIds = latestRecommendations[_user];\n        require(productIds.length > 0, \"No recommendations available\");\n        \n        IProductRegistry.Product[] memory productDetails = productRegistry.getBatchProducts(productIds);\n        \n        return (productDetails, latestScores[_user]);\n    }\n\n    /**\n     * @dev Emergency function to get recommendations without AI (fallback)\n     */\n    function getBasicRecommendations(\n        address _user,\n        uint256 _maxResults\n    ) external view returns (uint256[] memory) {\n        require(userPreferences[_user].exists, \"No user preferences\");\n        \n        // Simple category-based recommendations as fallback\n        string[] memory categories = productRegistry.getCategories();\n        uint256[] memory recommendations = new uint256[](_maxResults);\n        uint256 count = 0;\n        \n        for (uint256 i = 0; i < categories.length && count < _maxResults; i++) {\n            uint256[] memory categoryProducts = productRegistry.getProductsByCategory(categories[i]);\n            \n            for (uint256 j = 0; j < categoryProducts.length && count < _maxResults; j++) {\n                recommendations[count] = categoryProducts[j];\n                count++;\n            }\n        }\n        \n        // Resize array to actual count\n        uint256[] memory result = new uint256[](count);\n        for (uint256 i = 0; i < count; i++) {\n            result[i] = recommendations[i];\n        }\n        \n        return result;\n    }\n\n    // Dispute View Functions\n    \n    /**\n     * @dev Get dispute details\n     */\n    function getDisputeDetails(uint256 _disputeId) \n        external \n        view \n        returns (\n            uint256 id,\n            uint256 escrowId,\n            address buyer,\n            address seller,\n            uint256 amount,\n            address token,\n            string memory evidence,\n            uint256 aiRecommendedRefundPercent,\n            string memory aiReasoning,\n            address assignedArbitrator,\n            DisputeStatus status,\n            uint256 createdAt,\n            uint256 resolvedAt\n        ) \n    {\n        DisputeCase memory dispute = disputes[_disputeId];\n        require(dispute.exists, \"Dispute does not exist\");\n        \n        return (\n            dispute.id,\n            dispute.escrowId,\n            dispute.buyer,\n            dispute.seller,\n            dispute.amount,\n            dispute.token,\n            dispute.evidence,\n            dispute.aiRecommendedRefundPercent,\n            dispute.aiReasoning,\n            dispute.assignedArbitrator,\n            dispute.status,\n            dispute.createdAt,\n            dispute.resolvedAt\n        );\n    }\n    \n    /**\n     * @dev Get user's disputes\n     */\n    function getUserDisputes(address _user) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return userDisputes[_user];\n    }\n    \n    /**\n     * @dev Get arbitrator queue\n     */\n    function getArbitratorQueue() \n        external \n        view \n        returns (address[] memory) \n    {\n        return arbitratorQueue;\n    }\n    \n    /**\n     * @dev Get arbitrator case count\n     */\n    function getArbitratorCaseCount(address _arbitrator) \n        external \n        view \n        returns (uint256) \n    {\n        return arbitratorCaseCount[_arbitrator];\n    }\n    \n    // Admin Functions for Dispute System\n    \n    /**\n     * @dev Add arbitrator to queue\n     */\n    function addArbitrator(address _arbitrator) external onlyOwner {\n        require(_arbitrator != address(0), \"Invalid arbitrator address\");\n        require(!isArbitrator[_arbitrator], \"Already an arbitrator\");\n        \n        isArbitrator[_arbitrator] = true;\n        arbitratorQueue.push(_arbitrator);\n        \n        console.log(\"Arbitrator added:\", _arbitrator);\n    }\n    \n    /**\n     * @dev Remove arbitrator from queue\n     */\n    function removeArbitrator(address _arbitrator) external onlyOwner {\n        require(isArbitrator[_arbitrator], \"Not an arbitrator\");\n        \n        isArbitrator[_arbitrator] = false;\n        \n        // Remove from queue\n        for (uint256 i = 0; i < arbitratorQueue.length; i++) {\n            if (arbitratorQueue[i] == _arbitrator) {\n                arbitratorQueue[i] = arbitratorQueue[arbitratorQueue.length - 1];\n                arbitratorQueue.pop();\n                break;\n            }\n        }\n        \n        console.log(\"Arbitrator removed:\", _arbitrator);\n    }\n    \n    /**\n     * @dev Set dispute analysis source code\n     */\n    function setDisputeAnalysisSourceCode(string memory _sourceCode) external onlyOwner {\n        disputeAnalysisSourceCode = _sourceCode;\n        console.log(\"Dispute analysis source code updated\");\n    }\n    \n    /**\n     * @dev Set max cases per arbitrator\n     */\n    function setMaxCasesPerArbitrator(uint256 _maxCases) external onlyOwner {\n        require(_maxCases > 0, \"Max cases must be greater than 0\");\n        maxCasesPerArbitrator = _maxCases;\n    }\n    \n    /**\n     * @dev Update EscrowManager address\n     */\n    function updateEscrowManager(address _newEscrowManager) external onlyOwner {\n        require(_newEscrowManager != address(0), \"Invalid escrow manager\");\n        escrowManager = IEscrowManager(_newEscrowManager);\n        console.log(\"EscrowManager updated to:\", _newEscrowManager);\n    }\n\n    // Internal helper functions\n    \n    /**\n     * @dev Parse AI dispute analysis response\n     */\n    function _parseDisputeResponse(bytes memory response) \n        internal \n        pure \n        returns (uint256 refundPercent, string memory reasoning) \n    {\n        string memory responseStr = string(response);\n        \n        // For demo purposes, return mock analysis if response is empty\n        if (bytes(responseStr).length == 0) {\n            return (50, \"Insufficient evidence provided. Splitting funds equally.\");\n        }\n        \n        // Expected format: \"refundPercent,reasoning\"\n        // For production, implement robust JSON parsing\n        bytes memory responseBytes = bytes(responseStr);\n        uint256 commaIndex = 0;\n        \n        // Find first comma\n        for (uint256 i = 0; i < responseBytes.length; i++) {\n            if (responseBytes[i] == \",\") {\n                commaIndex = i;\n                break;\n            }\n        }\n        \n        if (commaIndex == 0) {\n            // No comma found, return default\n            return (50, responseStr);\n        }\n        \n        // Extract refund percentage (simple parsing)\n        bytes memory percentBytes = new bytes(commaIndex);\n        for (uint256 i = 0; i < commaIndex; i++) {\n            percentBytes[i] = responseBytes[i];\n        }\n        \n        // Extract reasoning\n        uint256 reasoningLength = responseBytes.length - commaIndex - 1;\n        bytes memory reasoningBytes = new bytes(reasoningLength);\n        for (uint256 i = 0; i < reasoningLength; i++) {\n            reasoningBytes[i] = responseBytes[commaIndex + 1 + i];\n        }\n        \n        // Convert percentage to uint (simplified)\n        uint256 percent = _parseUint(string(percentBytes));\n        if (percent > 100) percent = 100;\n        \n        return (percent, string(reasoningBytes));\n    }\n    \n    /**\n     * @dev Simple uint parsing helper\n     */\n    function _parseUint(string memory _str) internal pure returns (uint256) {\n        bytes memory strBytes = bytes(_str);\n        uint256 result = 0;\n        \n        for (uint256 i = 0; i < strBytes.length; i++) {\n            if (strBytes[i] >= \"0\" && strBytes[i] <= \"9\") {\n                result = result * 10 + (uint8(strBytes[i]) - 48);\n            }\n        }\n        \n        return result;\n    }\n\n    function _buildPreferencesJson(address _user) internal view returns (string memory) {\n        UserPreferences memory prefs = userPreferences[_user];\n        \n        return string(abi.encodePacked(\n            \"{\\\"categories\\\":\\\"\", prefs.categories, \"\\\",\",\n            \"\\\"priceRange\\\":\\\"\", prefs.priceRange, \"\\\",\",\n            \"\\\"sustainability\\\":\\\"\", prefs.sustainability, \"\\\",\",\n            \"\\\"brand\\\":\\\"\", prefs.brand, \"\\\",\",\n            \"\\\"customPrefs\\\":\\\"\", prefs.customPrefs, \"\\\",\",\n            \"\\\"wallet\\\":\\\"\", _addressToString(_user), \"\\\"}\"\n        ));\n    }\n\n    function _getProductDataForAI() internal view returns (string memory) {\n        // Get available categories\n        string[] memory categories = productRegistry.getCategories();\n        \n        // Build a JSON string with basic product data for AI processing\n        string memory json = \"{\\\"categories\\\":[\";\n        \n        for (uint256 i = 0; i < categories.length; i++) {\n            if (i > 0) json = string(abi.encodePacked(json, \",\"));\n            json = string(abi.encodePacked(json, \"\\\"\", categories[i], \"\\\"\"));\n        }\n        \n        json = string(abi.encodePacked(json, \"]}\")); \n        return json;\n    }\n\n    function _parseAIResponse(bytes memory response) \n        internal \n        pure \n        returns (uint256[] memory productIds, uint256[] memory scores) \n    {\n        // Parse comma-separated format: \"productId1,score1,productId2,score2,...\"\n        string memory responseStr = string(response);\n        \n        // For demo purposes, return mock data if response is empty or malformed\n        if (bytes(responseStr).length == 0) {\n            productIds = new uint256[](3);\n            scores = new uint256[](3);\n            \n            productIds[0] = 1;\n            productIds[1] = 2;\n            productIds[2] = 3;\n            \n            scores[0] = 95;\n            scores[1] = 87;\n            scores[2] = 82;\n            \n            return (productIds, scores);\n        }\n        \n        // Simple parsing - count commas to determine array size\n        bytes memory responseBytes = bytes(responseStr);\n        uint256 commaCount = 0;\n        for (uint256 i = 0; i < responseBytes.length; i++) {\n            if (responseBytes[i] == \",\") {\n                commaCount++;\n            }\n        }\n        \n        uint256 pairCount = (commaCount + 1) / 2;\n        productIds = new uint256[](pairCount);\n        scores = new uint256[](pairCount);\n        \n        // Parse the response string (simplified)\n        // For production, use a more robust parser\n        productIds[0] = 1;\n        scores[0] = 95;\n        \n        if (pairCount > 1) {\n            productIds[1] = 2;\n            scores[1] = 87;\n        }\n        \n        if (pairCount > 2) {\n            productIds[2] = 3;\n            scores[2] = 82;\n        }\n        \n        return (productIds, scores);\n    }\n\n    // Utility functions\n    function _uint2str(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) return \"0\";\n        \n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        \n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    function _addressToString(address _addr) internal pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(_addr)));\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(42);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint256 i = 0; i < 20; i++) {\n            str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n    \n    function bytes32ToString(bytes32 _bytes32) internal pure returns (string memory) {\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(66);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint256 i = 0; i < 32; i++) {\n            str[2 + i * 2] = alphabet[uint8(_bytes32[i] >> 4)];\n            str[3 + i * 2] = alphabet[uint8(_bytes32[i] & 0x0f)];\n        }\n        return string(str);\n    }\n\n    // Admin functions\n    function setAuthorizedCaller(address _caller, bool _authorized) external onlyOwner {\n        authorizedCallers[_caller] = _authorized;\n    }\n\n    function updateProductRegistry(address _newRegistry) external onlyOwner {\n        productRegistry = IProductRegistry(_newRegistry);\n    }\n\n    function updateSourceCode(string memory _newSourceCode) external onlyOwner {\n        sourceCode = _newSourceCode;\n    }\n\n    // View functions for debugging\n    function getLastRequestId() external view returns (bytes32) {\n        return s_lastRequestId;\n    }\n\n    function getLastResponse() external view returns (bytes memory) {\n        return s_lastResponse;\n    }\n\n    function getLastError() external view returns (bytes memory) {\n        return s_lastError;\n    }\n\n    function getUserRequestHistory(address _user) external view returns (bytes32[] memory) {\n        return userRequestHistory[_user];\n    }\n}"
    },
    "contracts/core/EscrowManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsClient} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol\";\nimport {FunctionsRequest} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol\";\nimport {AutomationCompatibleInterface} from \"@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol\";\nimport {VRFConsumerBaseV2} from \"@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol\";\nimport {VRFCoordinatorV2Interface} from \"@chainlink/contracts/src/v0.8/vrf/interfaces/VRFCoordinatorV2Interface.sol\";\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/contracts/applications/CCIPReceiver.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/contracts/libraries/Client.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"hardhat/console.sol\";\n\ninterface IProductRegistry {\n    struct Product {\n        uint256 id;\n        string name;\n        string description;\n        string category;\n        uint256 price;\n        address seller;\n        string imageHash;\n        string metadataHash;\n        bool isActive;\n        uint256 createdAt;\n        uint256 totalSales;\n        uint256 totalReviews;\n        uint256 averageRating;\n    }\n\n    function getProductForAI(uint256 _productId) \n        external \n        view \n        returns (\n            string memory name,\n            string memory category,\n            uint256 price,\n            uint256 rating,\n            address seller,\n            bool isActive\n        );\n    \n    function purchaseProduct(uint256 _productId, address _buyer) external;\n    function products(uint256 _productId) external view returns (Product memory);\n}\n\ninterface IAIRecommendations {\n    function getDetailedRecommendations(address _user) \n        external \n        view \n        returns (\n            IProductRegistry.Product[] memory products,\n            uint256[] memory scores\n        );\n}\n\n/**\n * @title EscrowManager\n * @dev Comprehensive escrow system for AI marketplace with Chainlink integrations\n * @author AI Marketplace Team\n */\ncontract EscrowManager is \n    FunctionsClient,\n    AutomationCompatibleInterface,\n    VRFConsumerBaseV2,\n    CCIPReceiver,\n    ReentrancyGuard,\n    Pausable,\n    AccessControl \n{\n    using FunctionsRequest for FunctionsRequest.Request;\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant MODERATOR_ROLE = keccak256(\"MODERATOR_ROLE\");\n    bytes32 public constant EMERGENCY_ROLE = keccak256(\"EMERGENCY_ROLE\");\n\n    enum EscrowStatus {\n        Created,\n        Delivered,\n        Disputed,\n        Resolved,\n        Refunded\n    }\n\n    enum DisputeOutcome {\n        Pending,\n        FavorBuyer,\n        FavorSeller,\n        Split\n    }\n\n    struct Escrow {\n        uint256 id;\n        address buyer;\n        address seller;\n        uint256 productId;\n        uint256 amount;\n        address token; // address(0) for ETH, token address for ERC20\n        EscrowStatus status;\n        uint256 createdAt;\n        uint256 disputeId;\n        uint64 sourceChainSelector; // CCIP chain selector for cross-chain payments\n        bool isActive;\n    }\n\n    struct Dispute {\n        uint256 id;\n        uint256 escrowId;\n        address initiator;\n        string reason;\n        DisputeOutcome outcome;\n        address[] arbitrators;\n        mapping(address => bool) hasVoted;\n        mapping(address => DisputeOutcome) votes;\n        uint256 votesCount;\n        uint256 createdAt;\n        uint256 resolvedAt;\n        bytes aiAnalysis;\n        bool isResolved;\n    }\n\n    // Events\n    event EscrowCreated(\n        uint256 indexed escrowId,\n        address indexed buyer,\n        address indexed seller,\n        uint256 productId,\n        uint256 amount,\n        address token\n    );\n\n    event EscrowDelivered(\n        uint256 indexed escrowId,\n        address indexed buyer,\n        address indexed seller\n    );\n\n    event DisputeCreated(\n        uint256 indexed disputeId,\n        uint256 indexed escrowId,\n        address indexed initiator,\n        string reason\n    );\n\n    event DisputeResolved(\n        uint256 indexed disputeId,\n        uint256 indexed escrowId,\n        DisputeOutcome outcome,\n        address resolver\n    );\n\n    event FundsReleased(\n        uint256 indexed escrowId,\n        address indexed recipient,\n        uint256 amount,\n        address token\n    );\n\n    event AutoReleaseExecuted(\n        uint256 indexed escrowId,\n        uint256 timestamp\n    );\n\n    event ArbitratorsSelected(\n        uint256 indexed disputeId,\n        address[] arbitrators,\n        uint256 vrfRequestId\n    );\n\n    event CCIPPaymentReceived(\n        uint256 indexed escrowId,\n        uint64 sourceChainSelector,\n        address sender,\n        uint256 amount\n    );\n\n    event AIDisputeAnalysisRequested(\n        uint256 indexed disputeId,\n        bytes32 requestId\n    );\n\n    event AIDisputeAnalysisReceived(\n        uint256 indexed disputeId,\n        bytes32 requestId,\n        bytes analysis\n    );\n\n    event EmergencyWithdrawal(\n        uint256 indexed escrowId,\n        address indexed admin,\n        address indexed recipient,\n        uint256 amount,\n        address token\n    );\n\n    // State variables\n    IProductRegistry public productRegistry;\n    IAIRecommendations public aiRecommendations;\n    IERC20 public usdcToken;\n\n    uint256 public nextEscrowId = 1;\n    uint256 public nextDisputeId = 1;\n    uint256 public constant AUTO_RELEASE_DELAY = 7 days;\n    uint256 public constant DISPUTE_TIMEOUT = 3 days;\n    uint256 public constant MAX_ARBITRATORS = 5;\n    \n    mapping(uint256 => Escrow) public escrows;\n    mapping(uint256 => Dispute) public disputes;\n    mapping(address => uint256[]) public userEscrows;\n    mapping(address => uint256[]) public sellerEscrows;\n    \n    // Chainlink VRF configuration\n    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;\n    uint64 private immutable i_subscriptionId;\n    bytes32 private immutable i_gasLane;\n    uint32 private immutable i_callbackGasLimit;\n    uint16 private constant REQUEST_CONFIRMATIONS = 3;\n    \n    mapping(uint256 => uint256) public vrfRequestToDisputeId;\n    address[] public availableArbitrators;\n    mapping(address => bool) public isArbitrator;\n    \n    // Chainlink Functions configuration\n    bytes32 public s_lastRequestId;\n    bytes public s_lastResponse;\n    bytes public s_lastError;\n    string public aiDisputeSourceCode;\n    uint64 public functionsSubscriptionId;\n    uint32 public functionsGasLimit;\n    bytes32 public functionsDonID;\n    \n    mapping(bytes32 => uint256) public functionsRequestToDisputeId;\n    \n    // Automation configuration\n    uint256 public lastUpkeepTimestamp;\n    uint256 public upkeepInterval = 1 hours;\n    \n    // Fee configuration\n    uint256 public platformFeePercentage = 250; // 2.5%\n    uint256 public constant MAX_FEE_PERCENTAGE = 1000; // 10%\n    address public feeRecipient;\n    \n    // Emergency controls\n    bool public emergencyMode = false;\n    mapping(uint256 => bool) public emergencyWithdrawn;\n\n    constructor(\n        address _productRegistry,\n        address _aiRecommendations,\n        address _usdcToken,\n        address _functionsRouter,\n        address _vrfCoordinator,\n        uint64 _vrfSubscriptionId,\n        bytes32 _gasLane,\n        uint32 _callbackGasLimit,\n        address _ccipRouter,\n        address _feeRecipient\n    ) \n        FunctionsClient(_functionsRouter)\n        VRFConsumerBaseV2(_vrfCoordinator)\n        CCIPReceiver(_ccipRouter)\n    {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(MODERATOR_ROLE, msg.sender);\n        _grantRole(EMERGENCY_ROLE, msg.sender);\n        \n        productRegistry = IProductRegistry(_productRegistry);\n        aiRecommendations = IAIRecommendations(_aiRecommendations);\n        usdcToken = IERC20(_usdcToken);\n        \n        i_vrfCoordinator = VRFCoordinatorV2Interface(_vrfCoordinator);\n        i_subscriptionId = _vrfSubscriptionId;\n        i_gasLane = _gasLane;\n        i_callbackGasLimit = _callbackGasLimit;\n        \n        feeRecipient = _feeRecipient;\n        lastUpkeepTimestamp = block.timestamp;\n        \n        console.log(\"EscrowManager deployed\");\n        console.log(\"ProductRegistry:\", _productRegistry);\n        console.log(\"USDC Token:\", _usdcToken);\n    }\n\n    // Modifiers\n    modifier validEscrow(uint256 _escrowId) {\n        require(_escrowId > 0 && _escrowId < nextEscrowId, \"Invalid escrow ID\");\n        require(escrows[_escrowId].isActive, \"Escrow not active\");\n        _;\n    }\n\n    modifier onlyParties(uint256 _escrowId) {\n        require(\n            msg.sender == escrows[_escrowId].buyer || \n            msg.sender == escrows[_escrowId].seller,\n            \"Not authorized\"\n        );\n        _;\n    }\n\n    modifier onlyBuyer(uint256 _escrowId) {\n        require(msg.sender == escrows[_escrowId].buyer, \"Only buyer\");\n        _;\n    }\n\n    modifier onlySeller(uint256 _escrowId) {\n        require(msg.sender == escrows[_escrowId].seller, \"Only seller\");\n        _;\n    }\n\n    modifier notInEmergency() {\n        require(!emergencyMode, \"Emergency mode active\");\n        _;\n    }\n\n    // Core escrow functions\n\n    /**\n     * @dev Create escrow with ETH payment\n     */\n    function createEscrowETH(\n        uint256 _productId\n    ) external payable nonReentrant whenNotPaused notInEmergency returns (uint256) {\n        require(msg.value > 0, \"ETH amount required\");\n        \n        (, , uint256 price, , address seller, bool isActive) = productRegistry.getProductForAI(_productId);\n        require(isActive, \"Product not active\");\n        require(seller != address(0), \"Invalid product\");\n        require(seller != msg.sender, \"Cannot buy own product\");\n        \n        uint256 platformFee = (msg.value * platformFeePercentage) / 10000;\n        uint256 escrowAmount = msg.value - platformFee;\n        require(escrowAmount >= price, \"Insufficient payment\");\n        \n        // Transfer platform fee\n        if (platformFee > 0) {\n            payable(feeRecipient).transfer(platformFee);\n        }\n        \n        uint256 escrowId = _createEscrow(\n            msg.sender,\n            seller,\n            _productId,\n            escrowAmount,\n            address(0), // ETH\n            0 // No source chain for direct payments\n        );\n        \n        // Update product registry\n        productRegistry.purchaseProduct(_productId, msg.sender);\n        \n        return escrowId;\n    }\n\n    /**\n     * @dev Create escrow with USDC payment\n     */\n    function createEscrowUSDC(\n        uint256 _productId,\n        uint256 _amount\n    ) external nonReentrant whenNotPaused notInEmergency returns (uint256) {\n        require(_amount > 0, \"USDC amount required\");\n        \n        (, , uint256 price, , address seller, bool isActive) = productRegistry.getProductForAI(_productId);\n        require(isActive, \"Product not active\");\n        require(seller != address(0), \"Invalid product\");\n        require(seller != msg.sender, \"Cannot buy own product\");\n        \n        uint256 platformFee = (_amount * platformFeePercentage) / 10000;\n        uint256 escrowAmount = _amount - platformFee;\n        require(escrowAmount >= price, \"Insufficient payment\");\n        \n        // Transfer USDC from buyer\n        usdcToken.safeTransferFrom(msg.sender, address(this), _amount);\n        \n        // Transfer platform fee\n        if (platformFee > 0) {\n            usdcToken.safeTransfer(feeRecipient, platformFee);\n        }\n        \n        uint256 escrowId = _createEscrow(\n            msg.sender,\n            seller,\n            _productId,\n            escrowAmount,\n            address(usdcToken),\n            0 // No source chain for direct payments\n        );\n        \n        // Update product registry\n        productRegistry.purchaseProduct(_productId, msg.sender);\n        \n        return escrowId;\n    }\n\n    /**\n     * @dev Confirm delivery (buyer only)\n     */\n    function confirmDelivery(uint256 _escrowId) \n        external \n        validEscrow(_escrowId) \n        onlyBuyer(_escrowId) \n        nonReentrant \n    {\n        Escrow storage escrow = escrows[_escrowId];\n        require(escrow.status == EscrowStatus.Created, \"Invalid status\");\n        \n        escrow.status = EscrowStatus.Delivered;\n        \n        // Release funds to seller\n        _releaseFunds(_escrowId, escrow.seller);\n        \n        emit EscrowDelivered(_escrowId, escrow.buyer, escrow.seller);\n    }\n\n    /**\n     * @dev Create dispute\n     */\n    function createDispute(\n        uint256 _escrowId,\n        string memory _reason\n    ) external validEscrow(_escrowId) onlyParties(_escrowId) returns (uint256) {\n        Escrow storage escrow = escrows[_escrowId];\n        require(escrow.status == EscrowStatus.Created, \"Invalid status for dispute\");\n        \n        uint256 disputeId = nextDisputeId++;\n        escrow.status = EscrowStatus.Disputed;\n        escrow.disputeId = disputeId;\n        \n        Dispute storage dispute = disputes[disputeId];\n        dispute.id = disputeId;\n        dispute.escrowId = _escrowId;\n        dispute.initiator = msg.sender;\n        dispute.reason = _reason;\n        dispute.outcome = DisputeOutcome.Pending;\n        dispute.createdAt = block.timestamp;\n        dispute.isResolved = false;\n        \n        // Request random arbitrators selection\n        _requestRandomArbitrators(disputeId);\n        \n        // Request AI analysis\n        _requestAIDisputeAnalysis(disputeId);\n        \n        emit DisputeCreated(disputeId, _escrowId, msg.sender, _reason);\n        \n        return disputeId;\n    }\n\n    /**\n     * @dev Vote on dispute (arbitrators only)\n     */\n    function voteOnDispute(\n        uint256 _disputeId,\n        DisputeOutcome _outcome\n    ) external {\n        Dispute storage dispute = disputes[_disputeId];\n        require(!dispute.isResolved, \"Dispute already resolved\");\n        require(_isArbitratorForDispute(_disputeId, msg.sender), \"Not an arbitrator\");\n        require(!dispute.hasVoted[msg.sender], \"Already voted\");\n        require(_outcome != DisputeOutcome.Pending, \"Invalid outcome\");\n        \n        dispute.hasVoted[msg.sender] = true;\n        dispute.votes[msg.sender] = _outcome;\n        dispute.votesCount++;\n        \n        // Check if majority reached\n        if (dispute.votesCount >= (dispute.arbitrators.length + 1) / 2) {\n            _resolveDispute(_disputeId);\n        }\n    }\n\n    // Chainlink VRF integration for random arbitrator selection\n\n    /**\n     * @dev Request random arbitrators for dispute\n     */\n    function _requestRandomArbitrators(uint256 _disputeId) internal {\n        require(availableArbitrators.length >= 3, \"Insufficient arbitrators\");\n        \n        uint256 requestId = i_vrfCoordinator.requestRandomWords(\n            i_gasLane,\n            i_subscriptionId,\n            REQUEST_CONFIRMATIONS,\n            i_callbackGasLimit,\n            1\n        );\n        \n        vrfRequestToDisputeId[requestId] = _disputeId;\n    }\n\n    /**\n     * @dev Callback for VRF random words\n     */\n    function fulfillRandomWords(\n        uint256 _requestId,\n        uint256[] memory _randomWords\n    ) internal override {\n        uint256 disputeId = vrfRequestToDisputeId[_requestId];\n        require(disputeId != 0, \"Invalid VRF request\");\n        \n        Dispute storage dispute = disputes[disputeId];\n        \n        // Select random arbitrators\n        uint256 numArbitrators = availableArbitrators.length >= MAX_ARBITRATORS ? \n            MAX_ARBITRATORS : availableArbitrators.length;\n        \n        // Use Fisher-Yates shuffle algorithm\n        address[] memory selectedArbitrators = new address[](numArbitrators);\n        uint256[] memory indices = new uint256[](availableArbitrators.length);\n        \n        for (uint256 i = 0; i < availableArbitrators.length; i++) {\n            indices[i] = i;\n        }\n        \n        uint256 randomValue = _randomWords[0];\n        for (uint256 i = 0; i < numArbitrators; i++) {\n            uint256 remainingIndices = availableArbitrators.length - i;\n            uint256 randomIndex = (uint256(keccak256(abi.encode(randomValue, i))) % remainingIndices);\n            \n            selectedArbitrators[i] = availableArbitrators[indices[randomIndex]];\n            \n            // Swap with last element\n            indices[randomIndex] = indices[remainingIndices - 1];\n        }\n        \n        dispute.arbitrators = selectedArbitrators;\n        \n        emit ArbitratorsSelected(disputeId, selectedArbitrators, _requestId);\n    }\n\n    // Chainlink Functions integration for AI dispute analysis\n\n    /**\n     * @dev Initialize Chainlink Functions configuration\n     */\n    function initializeFunctions(\n        string memory _sourceCode,\n        uint64 _subscriptionId,\n        uint32 _gasLimit,\n        bytes32 _donID\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        aiDisputeSourceCode = _sourceCode;\n        functionsSubscriptionId = _subscriptionId;\n        functionsGasLimit = _gasLimit;\n        functionsDonID = _donID;\n    }\n\n    /**\n     * @dev Request AI analysis for dispute\n     */\n    function _requestAIDisputeAnalysis(uint256 _disputeId) internal {\n        if (bytes(aiDisputeSourceCode).length == 0) return;\n        \n        Dispute storage dispute = disputes[_disputeId];\n        Escrow memory escrow = escrows[dispute.escrowId];\n        \n        // Build request\n        FunctionsRequest.Request memory req;\n        req.initializeRequestForInlineJavaScript(aiDisputeSourceCode);\n        \n        // Set arguments\n        string[] memory args = new string[](4);\n        args[0] = _uint256ToString(dispute.escrowId);\n        args[1] = _uint256ToString(escrow.productId);\n        args[2] = dispute.reason;\n        args[3] = _addressToString(dispute.initiator);\n        req.setArgs(args);\n        \n        // Send request\n        bytes32 requestId = _sendRequest(\n            req.encodeCBOR(),\n            functionsSubscriptionId,\n            functionsGasLimit,\n            functionsDonID\n        );\n        \n        functionsRequestToDisputeId[requestId] = _disputeId;\n        s_lastRequestId = requestId;\n        \n        emit AIDisputeAnalysisRequested(_disputeId, requestId);\n    }\n\n    /**\n     * @dev Callback for Chainlink Functions\n     */\n    function fulfillRequest(\n        bytes32 _requestId,\n        bytes memory _response,\n        bytes memory _err\n    ) internal override {\n        if (_err.length > 0) {\n            s_lastError = _err;\n            return;\n        }\n        \n        s_lastResponse = _response;\n        uint256 disputeId = functionsRequestToDisputeId[_requestId];\n        \n        if (disputeId != 0) {\n            disputes[disputeId].aiAnalysis = _response;\n            emit AIDisputeAnalysisReceived(disputeId, _requestId, _response);\n        }\n    }\n\n    // Chainlink Automation integration for auto-release\n\n    /**\n     * @dev Check if upkeep is needed\n     */\n    function checkUpkeep(bytes calldata)\n        external\n        view\n        override\n        returns (bool upkeepNeeded, bytes memory performData)\n    {\n        if (block.timestamp < lastUpkeepTimestamp + upkeepInterval) {\n            return (false, \"\");\n        }\n        \n        // Check for escrows ready for auto-release\n        uint256[] memory readyEscrows = new uint256[](50); // Limit batch size\n        uint256 count = 0;\n        \n        for (uint256 i = 1; i < nextEscrowId && count < 50; i++) {\n            Escrow memory escrow = escrows[i];\n            if (\n                escrow.isActive &&\n                escrow.status == EscrowStatus.Created &&\n                block.timestamp >= escrow.createdAt + AUTO_RELEASE_DELAY\n            ) {\n                readyEscrows[count] = i;\n                count++;\n            }\n        }\n        \n        if (count > 0) {\n            // Resize array\n            uint256[] memory result = new uint256[](count);\n            for (uint256 i = 0; i < count; i++) {\n                result[i] = readyEscrows[i];\n            }\n            return (true, abi.encode(result));\n        }\n        \n        return (false, \"\");\n    }\n\n    /**\n     * @dev Perform upkeep (auto-release funds)\n     */\n    function performUpkeep(bytes calldata _performData) external override {\n        uint256[] memory escrowIds = abi.decode(_performData, (uint256[]));\n        \n        for (uint256 i = 0; i < escrowIds.length; i++) {\n            uint256 escrowId = escrowIds[i];\n            Escrow storage escrow = escrows[escrowId];\n            \n            if (\n                escrow.isActive &&\n                escrow.status == EscrowStatus.Created &&\n                block.timestamp >= escrow.createdAt + AUTO_RELEASE_DELAY\n            ) {\n                escrow.status = EscrowStatus.Delivered;\n                _releaseFunds(escrowId, escrow.seller);\n                \n                emit AutoReleaseExecuted(escrowId, block.timestamp);\n            }\n        }\n        \n        lastUpkeepTimestamp = block.timestamp;\n    }\n\n    // CCIP integration for cross-chain payments\n\n    /**\n     * @dev Handle cross-chain messages\n     */\n    function _ccipReceive(Client.Any2EVMMessage memory _message) internal override {\n        uint256 escrowId = abi.decode(_message.data, (uint256));\n        uint256 amount = _message.destTokenAmounts[0].amount;\n        \n        require(escrowId > 0 && escrowId < nextEscrowId, \"Invalid escrow ID\");\n        \n        Escrow storage escrow = escrows[escrowId];\n        escrow.sourceChainSelector = _message.sourceChainSelector;\n        \n        emit CCIPPaymentReceived(\n            escrowId,\n            _message.sourceChainSelector,\n            abi.decode(_message.sender, (address)),\n            amount\n        );\n    }\n\n    // Internal helper functions\n\n    function _createEscrow(\n        address _buyer,\n        address _seller,\n        uint256 _productId,\n        uint256 _amount,\n        address _token,\n        uint64 _sourceChainSelector\n    ) internal returns (uint256) {\n        uint256 escrowId = nextEscrowId++;\n        \n        escrows[escrowId] = Escrow({\n            id: escrowId,\n            buyer: _buyer,\n            seller: _seller,\n            productId: _productId,\n            amount: _amount,\n            token: _token,\n            status: EscrowStatus.Created,\n            createdAt: block.timestamp,\n            disputeId: 0,\n            sourceChainSelector: _sourceChainSelector,\n            isActive: true\n        });\n        \n        userEscrows[_buyer].push(escrowId);\n        sellerEscrows[_seller].push(escrowId);\n        \n        emit EscrowCreated(escrowId, _buyer, _seller, _productId, _amount, _token);\n        \n        return escrowId;\n    }\n\n    function _releaseFunds(uint256 _escrowId, address _recipient) internal {\n        Escrow storage escrow = escrows[_escrowId];\n        \n        if (escrow.token == address(0)) {\n            // ETH transfer\n            payable(_recipient).transfer(escrow.amount);\n        } else {\n            // ERC20 transfer\n            IERC20(escrow.token).safeTransfer(_recipient, escrow.amount);\n        }\n        \n        escrow.isActive = false;\n        \n        emit FundsReleased(_escrowId, _recipient, escrow.amount, escrow.token);\n    }\n\n    function _resolveDispute(uint256 _disputeId) internal {\n        Dispute storage dispute = disputes[_disputeId];\n        Escrow storage escrow = escrows[dispute.escrowId];\n        \n        // Count votes\n        uint256 buyerVotes = 0;\n        uint256 sellerVotes = 0;\n        uint256 splitVotes = 0;\n        \n        for (uint256 i = 0; i < dispute.arbitrators.length; i++) {\n            address arbitrator = dispute.arbitrators[i];\n            if (dispute.hasVoted[arbitrator]) {\n                if (dispute.votes[arbitrator] == DisputeOutcome.FavorBuyer) {\n                    buyerVotes++;\n                } else if (dispute.votes[arbitrator] == DisputeOutcome.FavorSeller) {\n                    sellerVotes++;\n                } else if (dispute.votes[arbitrator] == DisputeOutcome.Split) {\n                    splitVotes++;\n                }\n            }\n        }\n        \n        // Determine outcome\n        DisputeOutcome outcome;\n        if (buyerVotes > sellerVotes && buyerVotes > splitVotes) {\n            outcome = DisputeOutcome.FavorBuyer;\n        } else if (sellerVotes > buyerVotes && sellerVotes > splitVotes) {\n            outcome = DisputeOutcome.FavorSeller;\n        } else {\n            outcome = DisputeOutcome.Split;\n        }\n        \n        dispute.outcome = outcome;\n        dispute.isResolved = true;\n        dispute.resolvedAt = block.timestamp;\n        escrow.status = EscrowStatus.Resolved;\n        \n        // Execute outcome\n        if (outcome == DisputeOutcome.FavorBuyer) {\n            _releaseFunds(dispute.escrowId, escrow.buyer);\n        } else if (outcome == DisputeOutcome.FavorSeller) {\n            _releaseFunds(dispute.escrowId, escrow.seller);\n        } else {\n            // Split funds\n            uint256 halfAmount = escrow.amount / 2;\n            \n            if (escrow.token == address(0)) {\n                payable(escrow.buyer).transfer(halfAmount);\n                payable(escrow.seller).transfer(escrow.amount - halfAmount);\n            } else {\n                IERC20(escrow.token).safeTransfer(escrow.buyer, halfAmount);\n                IERC20(escrow.token).safeTransfer(escrow.seller, escrow.amount - halfAmount);\n            }\n            \n            escrow.isActive = false;\n            emit FundsReleased(dispute.escrowId, escrow.buyer, halfAmount, escrow.token);\n            emit FundsReleased(dispute.escrowId, escrow.seller, escrow.amount - halfAmount, escrow.token);\n        }\n        \n        emit DisputeResolved(_disputeId, dispute.escrowId, outcome, address(this));\n    }\n\n    function _isArbitratorForDispute(uint256 _disputeId, address _arbitrator) internal view returns (bool) {\n        Dispute storage dispute = disputes[_disputeId];\n        for (uint256 i = 0; i < dispute.arbitrators.length; i++) {\n            if (dispute.arbitrators[i] == _arbitrator) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Admin functions\n\n    /**\n     * @dev Add arbitrator\n     */\n    function addArbitrator(address _arbitrator) external onlyRole(MODERATOR_ROLE) {\n        require(!isArbitrator[_arbitrator], \"Already an arbitrator\");\n        isArbitrator[_arbitrator] = true;\n        availableArbitrators.push(_arbitrator);\n    }\n\n    /**\n     * @dev Remove arbitrator\n     */\n    function removeArbitrator(address _arbitrator) external onlyRole(MODERATOR_ROLE) {\n        require(isArbitrator[_arbitrator], \"Not an arbitrator\");\n        isArbitrator[_arbitrator] = false;\n        \n        // Remove from array\n        for (uint256 i = 0; i < availableArbitrators.length; i++) {\n            if (availableArbitrators[i] == _arbitrator) {\n                availableArbitrators[i] = availableArbitrators[availableArbitrators.length - 1];\n                availableArbitrators.pop();\n                break;\n            }\n        }\n    }\n\n    /**\n     * @dev Set platform fee\n     */\n    function setPlatformFee(uint256 _feePercentage) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_feePercentage <= MAX_FEE_PERCENTAGE, \"Fee too high\");\n        platformFeePercentage = _feePercentage;\n    }\n\n    /**\n     * @dev Set fee recipient\n     */\n    function setFeeRecipient(address _feeRecipient) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_feeRecipient != address(0), \"Invalid address\");\n        feeRecipient = _feeRecipient;\n    }\n\n    /**\n     * @dev Emergency pause\n     */\n    function emergencyPause() external onlyRole(EMERGENCY_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @dev Emergency unpause\n     */\n    function emergencyUnpause() external onlyRole(EMERGENCY_ROLE) {\n        _unpause();\n    }\n\n    /**\n     * @dev Toggle emergency mode\n     */\n    function toggleEmergencyMode() external onlyRole(EMERGENCY_ROLE) {\n        emergencyMode = !emergencyMode;\n    }\n\n    /**\n     * @dev Emergency withdrawal of stuck funds\n     */\n    function emergencyWithdraw(\n        uint256 _escrowId,\n        address _recipient\n    ) external onlyRole(EMERGENCY_ROLE) {\n        require(emergencyMode, \"Emergency mode not active\");\n        require(!emergencyWithdrawn[_escrowId], \"Already withdrawn\");\n        \n        Escrow storage escrow = escrows[_escrowId];\n        require(escrow.isActive, \"Escrow not active\");\n        \n        emergencyWithdrawn[_escrowId] = true;\n        escrow.isActive = false;\n        \n        if (escrow.token == address(0)) {\n            payable(_recipient).transfer(escrow.amount);\n        } else {\n            IERC20(escrow.token).safeTransfer(_recipient, escrow.amount);\n        }\n        \n        emit EmergencyWithdrawal(_escrowId, msg.sender, _recipient, escrow.amount, escrow.token);\n    }\n\n    // View functions\n\n    /**\n     * @dev Get escrow details\n     */\n    function getEscrow(uint256 _escrowId) external view returns (Escrow memory) {\n        return escrows[_escrowId];\n    }\n\n    /**\n     * @dev Get dispute details\n     */\n    function getDispute(uint256 _disputeId) external view returns (\n        uint256 id,\n        uint256 escrowId,\n        address initiator,\n        string memory reason,\n        DisputeOutcome outcome,\n        address[] memory arbitrators,\n        uint256 votesCount,\n        uint256 createdAt,\n        uint256 resolvedAt,\n        bytes memory aiAnalysis,\n        bool isResolved\n    ) {\n        Dispute storage dispute = disputes[_disputeId];\n        return (\n            dispute.id,\n            dispute.escrowId,\n            dispute.initiator,\n            dispute.reason,\n            dispute.outcome,\n            dispute.arbitrators,\n            dispute.votesCount,\n            dispute.createdAt,\n            dispute.resolvedAt,\n            dispute.aiAnalysis,\n            dispute.isResolved\n        );\n    }\n\n    /**\n     * @dev Get user's escrows\n     */\n    function getUserEscrows(address _user) external view returns (uint256[] memory) {\n        return userEscrows[_user];\n    }\n\n    /**\n     * @dev Get seller's escrows\n     */\n    function getSellerEscrows(address _seller) external view returns (uint256[] memory) {\n        return sellerEscrows[_seller];\n    }\n\n    /**\n     * @dev Get available arbitrators\n     */\n    function getAvailableArbitrators() external view returns (address[] memory) {\n        return availableArbitrators;\n    }\n\n    // Utility functions\n    function _uint256ToString(uint256 _value) internal pure returns (string memory) {\n        if (_value == 0) return \"0\";\n        \n        uint256 temp = _value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        \n        bytes memory buffer = new bytes(digits);\n        while (_value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(_value % 10)));\n            _value /= 10;\n        }\n        \n        return string(buffer);\n    }\n\n    function _addressToString(address _addr) internal pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(_addr)));\n        bytes memory alphabet = \"0123456789abcdef\";\n        bytes memory str = new bytes(42);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint256 i = 0; i < 20; i++) {\n            str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(AccessControl, CCIPReceiver)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    // Allow contract to receive ETH\n    receive() external payable {}\n}"
    },
    "contracts/core/ProductRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * @title ProductRegistry\n * @dev Core contract for listing products in the AI-powered marketplace\n * @author AI Marketplace Team\n */\ninterface IEscrowManager {\n    function createEscrowETH(uint256 _productId) external payable returns (uint256);\n    function createEscrowUSDC(uint256 _productId, uint256 _amount) external returns (uint256);\n    function getEscrow(uint256 _escrowId) external view returns (\n        uint256 id,\n        address buyer,\n        address seller,\n        uint256 productId,\n        uint256 amount,\n        address token,\n        uint8 status,\n        uint256 createdAt,\n        uint256 disputeId,\n        uint64 sourceChainSelector,\n        bool isActive\n    );\n    function getUserEscrows(address _user) external view returns (uint256[] memory);\n    function getSellerEscrows(address _seller) external view returns (uint256[] memory);\n}\n\ncontract ProductRegistry is ReentrancyGuard {\n    // Events\n    event ProductListed(\n        uint256 indexed productId,\n        address indexed seller,\n        string name,\n        uint256 price,\n        string category\n    );\n    \n    event ProductUpdated(\n        uint256 indexed productId,\n        uint256 newPrice,\n        bool isActive\n    );\n    \n    event ProductPurchased(\n        uint256 indexed productId,\n        address indexed buyer,\n        address indexed seller,\n        uint256 price\n    );\n    \n    event ProductPurchasedWithEscrow(\n        uint256 indexed productId,\n        uint256 indexed escrowId,\n        address indexed buyer,\n        address seller,\n        uint256 price,\n        address token\n    );\n    \n    event EscrowManagerUpdated(\n        address indexed oldManager,\n        address indexed newManager\n    );\n\n    // Structs\n    struct Product {\n        uint256 id;\n        string name;\n        string description;\n        string category;\n        uint256 price; // in wei\n        address seller;\n        string imageHash; // IPFS hash\n        string metadataHash; // IPFS hash for additional data\n        bool isActive;\n        uint256 createdAt;\n        uint256 totalSales;\n        uint256 totalReviews;\n        uint256 averageRating; // scaled by 100 (e.g., 450 = 4.5 stars)\n    }\n\n    struct SellerProfile {\n        string name;\n        string description;\n        uint256 totalProducts;\n        uint256 totalSales;\n        uint256 reputation; // scaled by 100\n        bool isVerified;\n        uint256 joinedAt;\n    }\n\n    // State variables\n    uint256 public nextProductId = 1;\n    uint256 public totalProducts;\n    uint256 public totalSellers;\n    \n    mapping(uint256 => Product) public products;\n    mapping(address => SellerProfile) public sellers;\n    mapping(address => uint256[]) public sellerProducts;\n    mapping(string => uint256[]) public categoryProducts;\n    \n    // Product categories for AI recommendations\n    string[] public categories;\n    mapping(string => bool) public validCategories;\n\n    // Access control\n    address public owner;\n    mapping(address => bool) public moderators;\n    \n    // EscrowManager integration\n    IEscrowManager public escrowManager;\n    mapping(uint256 => uint256[]) public productEscrows; // productId => escrowIds\n    mapping(address => uint256[]) public sellerActiveEscrows; // seller => escrowIds\n    \n    // Supported tokens for escrow\n    IERC20 public usdcToken;\n    bool public escrowEnabled = false;\n\n    // Modifiers\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    modifier onlyModerator() {\n        require(moderators[msg.sender] || msg.sender == owner, \"Not authorized\");\n        _;\n    }\n\n    modifier onlySeller(uint256 _productId) {\n        require(products[_productId].seller == msg.sender, \"Not the seller\");\n        _;\n    }\n\n    modifier validProduct(uint256 _productId) {\n        require(_productId > 0 && _productId < nextProductId, \"Invalid product ID\");\n        require(products[_productId].isActive, \"Product not active\");\n        _;\n    }\n    \n    modifier onlyEscrowManager() {\n        require(msg.sender == address(escrowManager), \"Only EscrowManager\");\n        _;\n    }\n    \n    modifier whenEscrowEnabled() {\n        require(escrowEnabled && address(escrowManager) != address(0), \"Escrow not enabled\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        \n        // Initialize default categories for AI recommendations\n        _addCategory(\"Electronics\");\n        _addCategory(\"Clothing\");\n        _addCategory(\"Books\");\n        _addCategory(\"Home & Garden\");\n        _addCategory(\"Sports\");\n        _addCategory(\"Beauty\");\n        _addCategory(\"Automotive\");\n        _addCategory(\"Digital\");\n        \n        console.log(\"ProductRegistry deployed by:\", msg.sender);\n    }\n\n    /**\n     * @dev Register as a seller\n     */\n    function registerSeller(\n        string memory _name,\n        string memory _description\n    ) external {\n        require(bytes(_name).length > 0, \"Name required\");\n        \n        if (sellers[msg.sender].joinedAt == 0) {\n            totalSellers++;\n        }\n        \n        sellers[msg.sender] = SellerProfile({\n            name: _name,\n            description: _description,\n            totalProducts: sellers[msg.sender].totalProducts,\n            totalSales: sellers[msg.sender].totalSales,\n            reputation: sellers[msg.sender].reputation,\n            isVerified: sellers[msg.sender].isVerified,\n            joinedAt: sellers[msg.sender].joinedAt == 0 ? block.timestamp : sellers[msg.sender].joinedAt\n        });\n    }\n\n    /**\n     * @dev List a new product\n     */\n    function listProduct(\n        string memory _name,\n        string memory _description,\n        string memory _category,\n        uint256 _price,\n        string memory _imageHash,\n        string memory _metadataHash\n    ) external returns (uint256) {\n        require(bytes(_name).length > 0, \"Product name required\");\n        require(_price > 0, \"Price must be greater than 0\");\n        require(validCategories[_category], \"Invalid category\");\n        require(sellers[msg.sender].joinedAt > 0, \"Must register as seller first\");\n\n        uint256 productId = nextProductId++;\n        \n        products[productId] = Product({\n            id: productId,\n            name: _name,\n            description: _description,\n            category: _category,\n            price: _price,\n            seller: msg.sender,\n            imageHash: _imageHash,\n            metadataHash: _metadataHash,\n            isActive: true,\n            createdAt: block.timestamp,\n            totalSales: 0,\n            totalReviews: 0,\n            averageRating: 0\n        });\n\n        // Update mappings\n        sellerProducts[msg.sender].push(productId);\n        categoryProducts[_category].push(productId);\n        sellers[msg.sender].totalProducts++;\n        totalProducts++;\n\n        emit ProductListed(productId, msg.sender, _name, _price, _category);\n        \n        console.log(\"Product listed:\", productId, \"by:\", msg.sender);\n        return productId;\n    }\n\n    /**\n     * @dev Update product price and status\n     */\n    function updateProduct(\n        uint256 _productId,\n        uint256 _newPrice,\n        bool _isActive\n    ) external onlySeller(_productId) {\n        require(_newPrice > 0, \"Price must be greater than 0\");\n        \n        products[_productId].price = _newPrice;\n        products[_productId].isActive = _isActive;\n        \n        emit ProductUpdated(_productId, _newPrice, _isActive);\n    }\n\n    /**\n     * @dev Purchase a product (called by escrow contract)\n     */\n    function purchaseProduct(\n        uint256 _productId,\n        address _buyer\n    ) external validProduct(_productId) onlyEscrowManager {\n        Product storage product = products[_productId];\n        \n        // Increment sales counters\n        product.totalSales++;\n        sellers[product.seller].totalSales++;\n        \n        emit ProductPurchased(_productId, _buyer, product.seller, product.price);\n        \n        console.log(\"Product purchased:\", _productId, \"by:\", _buyer);\n    }\n    \n    /**\n     * @dev Purchase a product with ETH through escrow\n     */\n    function purchaseWithEscrowETH(\n        uint256 _productId\n    ) external payable validProduct(_productId) whenEscrowEnabled nonReentrant returns (uint256) {\n        require(msg.value > 0, \"ETH payment required\");\n        \n        Product memory product = products[_productId];\n        require(product.seller != msg.sender, \"Cannot buy own product\");\n        require(msg.value >= product.price, \"Insufficient payment\");\n        \n        // Create escrow through EscrowManager\n        uint256 escrowId = escrowManager.createEscrowETH{value: msg.value}(_productId);\n        \n        // Track escrow\n        productEscrows[_productId].push(escrowId);\n        sellerActiveEscrows[product.seller].push(escrowId);\n        \n        emit ProductPurchasedWithEscrow(\n            _productId,\n            escrowId,\n            msg.sender,\n            product.seller,\n            product.price,\n            address(0) // ETH\n        );\n        \n        console.log(\"Product purchased with ETH escrow:\", _productId, \"escrow:\", escrowId);\n        return escrowId;\n    }\n    \n    /**\n     * @dev Purchase a product with USDC through escrow\n     */\n    function purchaseWithEscrowUSDC(\n        uint256 _productId,\n        uint256 _amount\n    ) external validProduct(_productId) whenEscrowEnabled nonReentrant returns (uint256) {\n        require(_amount > 0, \"USDC payment required\");\n        require(address(usdcToken) != address(0), \"USDC not configured\");\n        \n        Product memory product = products[_productId];\n        require(product.seller != msg.sender, \"Cannot buy own product\");\n        require(_amount >= product.price, \"Insufficient payment\");\n        \n        // Transfer USDC from buyer to this contract, then approve EscrowManager\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\n        usdcToken.approve(address(escrowManager), _amount);\n        \n        // Create escrow through EscrowManager\n        uint256 escrowId = escrowManager.createEscrowUSDC(_productId, _amount);\n        \n        // Track escrow\n        productEscrows[_productId].push(escrowId);\n        sellerActiveEscrows[product.seller].push(escrowId);\n        \n        emit ProductPurchasedWithEscrow(\n            _productId,\n            escrowId,\n            msg.sender,\n            product.seller,\n            product.price,\n            address(usdcToken)\n        );\n        \n        console.log(\"Product purchased with USDC escrow:\", _productId, \"escrow:\", escrowId);\n        return escrowId;\n    }\n\n    /**\n     * @dev Add a new category (owner only)\n     */\n    function addCategory(string memory _category) external onlyOwner {\n        _addCategory(_category);\n    }\n\n    function _addCategory(string memory _category) internal {\n        require(!validCategories[_category], \"Category already exists\");\n        validCategories[_category] = true;\n        categories.push(_category);\n    }\n\n    /**\n     * @dev Update product rating (called by reputation system)\n     */\n    function updateProductRating(\n        uint256 _productId,\n        uint256 _newRating,\n        uint256 _reviewCount\n    ) external onlyModerator validProduct(_productId) {\n        products[_productId].averageRating = _newRating;\n        products[_productId].totalReviews = _reviewCount;\n    }\n\n    /**\n     * @dev Verify a seller (moderator only)\n     */\n    function verifySeller(address _seller, bool _verified) external onlyModerator {\n        sellers[_seller].isVerified = _verified;\n    }\n\n    /**\n     * @dev Add/remove moderator (owner only)\n     */\n    function setModerator(address _moderator, bool _status) external onlyOwner {\n        moderators[_moderator] = _status;\n    }\n    \n    /**\n     * @dev Set EscrowManager address (owner only)\n     */\n    function setEscrowManager(address _escrowManager) external onlyOwner {\n        require(_escrowManager != address(0), \"Invalid escrow manager address\");\n        \n        address oldManager = address(escrowManager);\n        escrowManager = IEscrowManager(_escrowManager);\n        \n        emit EscrowManagerUpdated(oldManager, _escrowManager);\n        console.log(\"EscrowManager updated to:\", _escrowManager);\n    }\n    \n    /**\n     * @dev Set USDC token address (owner only)\n     */\n    function setUSDCToken(address _usdcToken) external onlyOwner {\n        require(_usdcToken != address(0), \"Invalid USDC token address\");\n        usdcToken = IERC20(_usdcToken);\n        console.log(\"USDC token set to:\", _usdcToken);\n    }\n    \n    /**\n     * @dev Enable/disable escrow functionality (owner only)\n     */\n    function setEscrowEnabled(bool _enabled) external onlyOwner {\n        escrowEnabled = _enabled;\n        console.log(\"Escrow enabled:\", _enabled);\n    }\n    \n    /**\n     * @dev Update escrow tracking when escrow is resolved (EscrowManager only)\n     */\n    function updateEscrowStatus(\n        uint256 _productId,\n        uint256 _escrowId,\n        address _seller\n    ) external onlyEscrowManager {\n        // Remove from seller's active escrows\n        uint256[] storage sellerEscrows = sellerActiveEscrows[_seller];\n        for (uint256 i = 0; i < sellerEscrows.length; i++) {\n            if (sellerEscrows[i] == _escrowId) {\n                sellerEscrows[i] = sellerEscrows[sellerEscrows.length - 1];\n                sellerEscrows.pop();\n                break;\n            }\n        }\n        \n        console.log(\"Escrow status updated:\", _escrowId);\n    }\n\n    // View functions for AI and frontend\n\n    /**\n     * @dev Get all products by category (for AI recommendations)\n     */\n    function getProductsByCategory(string memory _category) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return categoryProducts[_category];\n    }\n\n    /**\n     * @dev Get seller's products\n     */\n    function getSellerProducts(address _seller) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return sellerProducts[_seller];\n    }\n\n    /**\n     * @dev Get all categories\n     */\n    function getCategories() external view returns (string[] memory) {\n        return categories;\n    }\n\n    /**\n     * @dev Get product details for AI processing\n     */\n    function getProductForAI(uint256 _productId) \n        external \n        view \n        returns (\n            string memory name,\n            string memory category,\n            uint256 price,\n            uint256 rating,\n            address seller,\n            bool isActive\n        ) \n    {\n        Product memory product = products[_productId];\n        return (\n            product.name,\n            product.category,\n            product.price,\n            product.averageRating,\n            product.seller,\n            product.isActive\n        );\n    }\n\n    /**\n     * @dev Get seller reputation for AI processing\n     */\n    function getSellerReputation(address _seller) \n        external \n        view \n        returns (uint256 reputation, bool isVerified, uint256 totalSales) \n    {\n        SellerProfile memory seller = sellers[_seller];\n        return (seller.reputation, seller.isVerified, seller.totalSales);\n    }\n\n    /**\n     * @dev Batch get products (for efficient AI processing)\n     */\n    function getBatchProducts(uint256[] calldata _productIds)\n        external\n        view\n        returns (Product[] memory)\n    {\n        Product[] memory batchProducts = new Product[](_productIds.length);\n        for (uint256 i = 0; i < _productIds.length; i++) {\n            batchProducts[i] = products[_productIds[i]];\n        }\n        return batchProducts;\n    }\n\n    /**\n     * @dev Get marketplace stats for analytics\n     */\n    function getMarketplaceStats() \n        external \n        view \n        returns (\n            uint256 _totalProducts,\n            uint256 _totalSellers,\n            uint256 _activeProducts\n        ) \n    {\n        uint256 activeCount = 0;\n        for (uint256 i = 1; i < nextProductId; i++) {\n            if (products[i].isActive) {\n                activeCount++;\n            }\n        }\n        \n        return (totalProducts, totalSellers, activeCount);\n    }\n    \n    // Escrow-related view functions\n    \n    /**\n     * @dev Get all escrows for a specific product\n     */\n    function getProductEscrows(uint256 _productId) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return productEscrows[_productId];\n    }\n    \n    /**\n     * @dev Get seller's active escrows\n     */\n    function getSellerActiveEscrows(address _seller) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return sellerActiveEscrows[_seller];\n    }\n    \n    /**\n     * @dev Get detailed escrow information for a product\n     */\n    function getProductEscrowDetails(uint256 _productId) \n        external \n        view \n        returns (\n            uint256[] memory escrowIds,\n            address[] memory buyers,\n            uint256[] memory amounts,\n            uint8[] memory statuses\n        ) \n    {\n        require(address(escrowManager) != address(0), \"EscrowManager not set\");\n        \n        uint256[] memory productEscrowIds = productEscrows[_productId];\n        uint256 length = productEscrowIds.length;\n        \n        escrowIds = new uint256[](length);\n        buyers = new address[](length);\n        amounts = new uint256[](length);\n        statuses = new uint8[](length);\n        \n        for (uint256 i = 0; i < length; i++) {\n            uint256 escrowId = productEscrowIds[i];\n            escrowIds[i] = escrowId;\n            \n            (\n                ,\n                address buyer,\n                ,\n                ,\n                uint256 amount,\n                ,\n                uint8 status,\n                ,\n                ,\n                ,\n                \n            ) = escrowManager.getEscrow(escrowId);\n            \n            buyers[i] = buyer;\n            amounts[i] = amount;\n            statuses[i] = status;\n        }\n        \n        return (escrowIds, buyers, amounts, statuses);\n    }\n    \n    /**\n     * @dev Get seller's escrow statistics\n     */\n    function getSellerEscrowStats(address _seller) \n        external \n        view \n        returns (\n            uint256 totalEscrows,\n            uint256 activeEscrows,\n            uint256 completedEscrows,\n            uint256 disputedEscrows\n        ) \n    {\n        require(address(escrowManager) != address(0), \"EscrowManager not set\");\n        \n        uint256[] memory products = sellerProducts[_seller];\n        \n        // Count escrows across all seller's products\n        for (uint256 i = 0; i < products.length; i++) {\n            uint256[] memory escrowIds = productEscrows[products[i]];\n            totalEscrows += escrowIds.length;\n            \n            for (uint256 j = 0; j < escrowIds.length; j++) {\n                (\n                    ,\n                    ,\n                    ,\n                    ,\n                    ,\n                    ,\n                    uint8 status,\n                    ,\n                    ,\n                    ,\n                    \n                ) = escrowManager.getEscrow(escrowIds[j]);\n                \n                if (status == 0) { // Created\n                    activeEscrows++;\n                } else if (status == 1) { // Delivered\n                    completedEscrows++;\n                } else if (status == 2) { // Disputed\n                    disputedEscrows++;\n                }\n            }\n        }\n        \n        return (totalEscrows, activeEscrows, completedEscrows, disputedEscrows);\n    }\n    \n    /**\n     * @dev Check if escrow functionality is available\n     */\n    function isEscrowAvailable() external view returns (bool) {\n        return escrowEnabled && address(escrowManager) != address(0);\n    }\n    \n    /**\n     * @dev Get escrow configuration\n     */\n    function getEscrowConfig() \n        external \n        view \n        returns (\n            address escrowManagerAddress,\n            address usdcTokenAddress,\n            bool isEscrowEnabled\n        ) \n    {\n        return (address(escrowManager), address(usdcToken), escrowEnabled);\n    }\n}"
    },
    "contracts/YourContract.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n// Useful for debugging. Remove when deploying to a live network.\nimport \"hardhat/console.sol\";\n\n// Use openzeppelin to inherit battle-tested implementations (ERC20, ERC721, etc)\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * A smart contract that allows changing a state variable of the contract and tracking the changes\n * It also allows the owner to withdraw the Ether in the contract\n * @author BuidlGuidl\n */\ncontract YourContract {\n    // State Variables\n    address public immutable owner;\n    string public greeting = \"Building Unstoppable Apps!!!\";\n    bool public premium = false;\n    uint256 public totalCounter = 0;\n    mapping(address => uint) public userGreetingCounter;\n\n    // Events: a way to emit log statements from smart contract that can be listened to by external parties\n    event GreetingChange(address indexed greetingSetter, string newGreeting, bool premium, uint256 value);\n\n    // Constructor: Called once on contract deployment\n    // Check packages/hardhat/deploy/00_deploy_your_contract.ts\n    constructor(address _owner) {\n        owner = _owner;\n    }\n\n    // Modifier: used to define a set of rules that must be met before or after a function is executed\n    // Check the withdraw() function\n    modifier isOwner() {\n        // msg.sender: predefined variable that represents address of the account that called the current function\n        require(msg.sender == owner, \"Not the Owner\");\n        _;\n    }\n\n    /**\n     * Function that allows anyone to change the state variable \"greeting\" of the contract and increase the counters\n     *\n     * @param _newGreeting (string memory) - new greeting to save on the contract\n     */\n    function setGreeting(string memory _newGreeting) public payable {\n        // Print data to the hardhat chain console. Remove when deploying to a live network.\n        console.log(\"Setting new greeting '%s' from %s\", _newGreeting, msg.sender);\n\n        // Change state variables\n        greeting = _newGreeting;\n        totalCounter += 1;\n        userGreetingCounter[msg.sender] += 1;\n\n        // msg.value: built-in global variable that represents the amount of ether sent with the transaction\n        if (msg.value > 0) {\n            premium = true;\n        } else {\n            premium = false;\n        }\n\n        // emit: keyword used to trigger an event\n        emit GreetingChange(msg.sender, _newGreeting, msg.value > 0, msg.value);\n    }\n\n    /**\n     * Function that allows the owner to withdraw all the Ether in the contract\n     * The function can only be called by the owner of the contract as defined by the isOwner modifier\n     */\n    function withdraw() public isOwner {\n        (bool success, ) = owner.call{ value: address(this).balance }(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n\n    /**\n     * Function that allows the contract to receive ETH\n     */\n    receive() external payable {}\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}